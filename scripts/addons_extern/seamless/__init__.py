# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

bl_info = {
    "name": "Piles'N'Tiles",
    "author": "Jesse Sutherland (SynaGl0w)",
    "version": (0, 1),
    "blender": (2, 7, 4),
    "location": "Tool Shelf > Seamless Tab",
    "description": "Seamless tools for blender.",
    "warning": "Work in Progress!",
    "wiki_url": "",
    "tracker_url": "http://blenderartists.org/forum/showthread.php?377518-Addon-Piles-N-Tiles-Seamless-Tools-for-Blender",
    "category": "Object"}

import bpy
from bpy.types import Operator, Panel, PropertyGroup, AddonPreferences
from bpy.props import *
from bgl import *
from mathutils import Vector, Matrix
from collections import defaultdict
from random import seed, random

SEAMLESS_AREA_NAME = "~seamless_area"
SEAMLESS_OBJECTS_NAME = "~seamless_objects"
SEAMLESS_PROXIES_NAME = "~seamless_proxies"
SEAMLESS_MARGIN_NAME = "~seamless_margin"
SEAMLESS_FLOOR_NAME = "~seamless_floor"
SEAMLESS_CAMERA_NAME = "~seamless_camera"
SEAMLESS_PROXY_GROUP = "~sproxies.000"
SEAMLESS_PROXY_NAME = "~sproxy.000"
SEAMLESS_PROXY_PREFIX = "~sproxies"
SEAMLESS_LOC = "seamless_loc"
SEAMLESS_LEVEL = "seamless_level"
SEAMLESS_CLIP = "seamless_clip"


def unpack_node_groups():  # *** Generated by node groups to python packer. Very WIP! ***
    from json import loads
    from zlib import decompress
    from base64 import b64decode
    groups = (
        "eNrtXFtv4sgSfia/AvEc+nT1vc9bZrM7ipTLKJfRzDlaISc4G84SjMDMZjWa+e2nDfgK3bYxWchlpIwBl9vVVe2q+qqq/f2g1fljEszG086/2/89aLW+m79W"
        "ZzgY/Rn/0mot/m+Jw8URL48Qf58ffj9cRxvTkAq0MQ110EKBB+agJRZaWENLLbRkDS0u0EoHD7JAKxy0rEDL87QHyQWdkffoG+10LoPZqN/+7N+FwaSzPBX0"
        "/VRz3xcjdIbBnRcOglFyotXqUiKQIrFAW12OCMd68W3JWHqnj9EaaZ+MxrOwE5/7a9APH3oPg37fjwbmCglM4gl3ft5F150bdubX5i/9GYwzrNx7w6kf8xFO"
        "Zms/54jmX5aszg8/DsvmyzFiisV6blGBOAPbdM+88CFhNhj7k3i0zuXFzflxcmo29Xt3Q+8xmk2WwaJsKEaYcp6XzdWD1/cnkYRyt/s5MCeXE2l1IPOl1en7"
        "995sGPa+ecNZxGi8VMwpc6/ol0hky99+LI4/dit0zjFP1hhGBDPqEDrCGLYpeGIWJZH6TQpes1Tw5cvdSJ5sVfISacLgzUkeJDWLXCeSB4QZobY1/0vweDsY"
        "+e3Ljx9sdpURmwyXF2evfe4JD6Y97y4cfPN7wSyMLPpC/Id2eRBNkILYLSydmc3BXCwGtUhCaISV4hYPU7h2B6rvKo4Y1lndc0G0TfdX/tgzT9mGyo+v/ie1"
        "v27OoDSiWmRMvFKSScucF7FK2+5fj46PbbIw8QoHYXWii6E3tivxhMwSRYndXP0Sf/69nhmy87ELI5YJJYtSvJ74/jKUnEsvH0fahJaRUv5jYRk8ek/JtYDN"
        "v+TEYJSc6ObO5FdOZ/Xhvwru/vTD5enV+QXVJ3G48sHB/lrWm3N9sFS8A4fxArZiFbBVEbNABWyFHRioiJdIDRxWBwNRBw/MgkehIWbjFh7AQUsKR6iE2dq/"
        "Pjlh2+3QH/V74d/jRZR2c3p98un0a8fhbUEzRFIPJE30K8AacA+ecvF2FNp5w/GDVwztqsZ8dm9lbpVzVDnDjJ2GGfYq4PNu/WE0NfjXyKUHIRGTadTTBWbc"
        "oqiNNo9PPp8c/1o79jZ3E1hvEnu/JFWsCUYEN7FImtMgGoEmG8ciVzcfri+PfrmuH5yti0X2LAY4bGhpTOBnol1QSUIFIwyK2E3Nu5nZwMyceU9OJVDMTVDM"
        "UjsT4X4qNsqwnB19OTm7OauP9AkSlLPtI33DKt57k8MkR0Qklt6AFCoI2TyNKgCRlbzJ/qRRGSAlaTpdhRgF5Zqu0SJLOI7inF4YYYy16etYHNHzSLBFQhIb"
        "I4+tOb35TeuKaFUsz5cRoRgQJDbMxGiaAlZN8iIUKcblrvIi20eTtYAYrMeQTZDYoZNNVQvN5qxYmvu584a+lZnfhoEXVuKlEQCvJriL+/upH74DbwOuWBHl"
        "ueApFDEy8BpAnbuAehGpgwvWSwucrVKuxA5a3CAF4ILUqkaJt0irHbS6RvkaapSOeY3UAhSFplzEzDIyuIihMHKVajfQGikZcCkPVpoEnOIorjdwKRuKqwhE"
        "aYX8yvceh/502r6eeKPpfTB5rFsnlwQRnGSdWwphwShzBtgEb7V2TBBVz1HCzGS29wnydA1jzhSXYIiRtMjCMJKEcbdGSEWEX6O6CYy/62S9TiTiknB3nZ/Q"
        "d5VsB5IRgQ1kTDpbCEVMKukWPtuy8B0pmXwSbNfS6RKGFKiStclfqXjS7LU7rQQG5nOaQFRuZIZLZIbpdlPYyng9+spT2HfB0ICQjBktBUKJBq8HQ7/9xalE"
        "QgVKM0mREiXVtshlugyUeqEZuPdkrcGbQZTdyn6eS3l9yrtEL2KPcnpUI5H6khYFRAl3x3xgiTBWUukv36IWxdMFgbQEt8cB+mbkU0AMUYBKKClxyPAOGZ7T"
        "nRlLyEW2J49gVlIl4e/+rKk/S9wYVPNnX0v8mZGhyNTUTVBiN8t5h/b323ZowphoSOO5LgdjsVWDIpVEVNO97fVnBJDgmek649e4B/fL1/9s3IObvXY3XZhG"
        "oyxNinCKJANW1nnqmHK0RDgVZe2n/+TE65fauAndIO1RiMRi1oFuUmuTBhiB2I8eZCt+KLe3SWK0UN5ZW+JWJp6QIitFSleaDB69JycrUKQfjGrVgFYMuzfx"
        "vV6QZ38ShEX2cdqabBt6Oq/G1WE+jNLJQ+utrHeKwoWFoFY6XxbyyP38bV6lStpyPl2cnFubkaQ2QbaW9gBjPB6M/nhRS/MyVqazA4YRBCK3ODGTei8W56Q4"
        "gbe7PDVFWmC6u+X5+roUXnmxfYNSNDQoReMau4I32L3rLBmX1zF/86Zh+zwYTH13/TK2oceB26UTrRFTqdUUHGETMG7aKXt8cd37dHlxfGNvlgWNIN0K+ny7"
        "d4BFkW+6Z8cYHqFT6GOED4gRopONPJX27OA969ddG6ZRjjKFDsGQNpivEchTaYPv3oG8LgGMILO5WESVHVF/S/fVyXn9fI5BmIwK+ua2t3aBMEQzyV9BDSAq"
        "Kb9bO46fO/lbQ/BSUwFI7rzhO+iXdN0jKTTLih+klhuV5s6MwT692HDpb18D+9mBf3Q7dW70EYjqTIbBGCHMSmpFto32Rx+uLk5vrjdILktECeWvWyP1sz/A"
        "FKIZS0VMJCCgQfIn2trPhX49jdYvedsuboBX8ll9R/d1VbRSp30XN0AKpEZX57aad6EBCiL5BmlXh+bRxPec4KY8pVR8tte1AzGKFE/tdfRIC7dRyMUvuQ0s"
        "tu7SzDYWQowNIsJmuNMHZsfbWBJ/9ymYDsqSbhQbrydTIQKnSHNbDPjRDx79cGItwVER7Y21eq9z/6+VEWpupowZ7ZDKlLQyJatMyStTisqUcs+AaX0vLahE"
        "kElFyOglUbLRfiiFGMfN3XSNx6zKk3Vx+z/j7dqnsQgcMtHm+QKZYnlJDJa3PV/LcU9G94FNIgrPC6C2R2wxQm6APXjC9qUZr457YSCiVy5kLCNDxLofN3Yv"
        "5PW7l/WiotmmHMBIOEuz5btIkxdqZDeSKoU0ZbaQfg6dSEUx5bAT2eH7hJ5ZXeWNqWCr3l3602A4KzNw0VvBOGR0T6LWHovyJ6tDFpsVooq0gO138Ri4t5dv"
        "ZdqPuo/NozXYXPuc7B6Nx5Pgqf3CuF4JyKuV1w7M4cf/AZ9tUMw="
    )
    groups = loads(decompress(b64decode(groups)).decode())["groups"]
    s_c, s_n, s_dv, s_vmi, s_vma, s_i, s_o, s_no, s_li = "~c", "name", "default_value", "min_value", "max_value", "~i", "~o", "nodes", "links"

    def is_group(d, g):
        i, o = d.get(s_i, []), d.get(s_o, [])
        b = "|"
        s1 = str(len(i)) + b + str(len(o)) + b
        for s in i and o:
            s1 += s[s_c]
        i, o = g.inputs, g.outputs
        s2 = str(len(i)) + b + str(len(o)) + b
        for s in i and o:
            s2 += s.bl_socket_idname
        return s1 == s2

    def d2o(d, o, n):
        try:
            v = d[n]
        except:
            return
        try:
            l = len(v)
        except:
            l = 0
        try:
            if l and isinstance(v, list):
                setattr(o, n, v[:])
            else:
                setattr(o, n, v)
        except:
            pass
    gm = {}

    def _nh_nop(d, o, n): pass

    def _nh_i(d, o, n):
        for k, v in d[n].items():
            try:
                s = o.inputs[int(k)]
            except:
                continue
            for a in v:
                d2o(v, s, a)

    def _nh_o(d, o, n):
        for k, v in d[n].items():
            try:
                s = o.outputs[int(k)]
            except:
                continue
            for a in v:
                d2o(v, s, a)

    def _nh_op(d, o, n): o.mute, o.hide, o.show_options, o.show_preview, o.show_texture = d[n]

    def _nh_tree(d, o, n): o.node_tree = gm[d[n]]

    def _nh_wh(d, o, n): old = o.bl_width_min
    o.bl_width_min = 0
    d2o(d, o, n)
    o.bl_width_min = old

    def _nh_col(d, o, n): d2o(d, o, n)
    o.use_custom_color = True
    _nh = {s_c: _nh_nop, s_i: _nh_i, s_o: _nh_o, "~op": _nh_op, "node_tree": _nh_tree, "color": _nh_col, "width_hidden": _nh_wh}
    ngd = bpy.data.node_groups
    for d in groups:
        name = d[s_n]
        try:
            g = ngd[name]
        except:
            pass
        else:
            if is_group(d, g):
                gm[name] = g
                continue
        g = ngd.new(name, d[s_c])
        gm[name] = g
        i, o = d.get(s_i, []), d.get(s_o, [])
        gi, go = g.inputs, g.outputs
        for s in i:
            sk = gi.new(s[s_c], s[s_n])
            d2o(s, sk, s_dv)
            d2o(s, sk, s_vmi)
            d2o(s, sk, s_vma)
        for s in o:
            sk = go.new(s[s_c], s[s_n])
            d2o(s, sk, s_dv)
            d2o(s, sk, s_vmi)
            d2o(s, sk, s_vma)
        nodes, nl = g.nodes, []
        for dn in d[s_no]:
            n = nodes.new(dn[s_c])
            n.select = False
            nl.append(n)
            for a in dn:
                try:
                    _nh[a](dn, n, a)
                except:
                    d2o(dn, n, a)
        links = g.links
        for l in d[s_li]:
            try:
                links.new(nl[l[0]].outputs[l[1]], nl[l[2]].inputs[l[3]])
            except:
                pass
    for g in gm.values():
        g.use_fake_user = True

# Group Management


def get_group(name, create=False):
    groups = bpy.data.groups
    try:
        group = groups[name]
    except KeyError:
        group = None
        if create:
            group = groups.new(name)
    return group


def get_so_group(create=False):
    return get_group(SEAMLESS_OBJECTS_NAME, create)


def get_sp_group(create=False):
    return get_group(SEAMLESS_PROXIES_NAME, create)


def get_ma_group(create=False):
    return get_group(SEAMLESS_MARGIN_NAME, create)

# Object Management


def get_object(name, context, create=False, setup_callback=None, data=None):
    scene = context.scene
    scene_objects = scene.objects
    try:
        obj = scene_objects[name]
    except KeyError:
        blend_objects = bpy.data.objects
        try:
            obj = blend_objects[name]
        except KeyError:
            obj = None
            if create:
                if callable(data):
                    data = data(name, context)
                obj = blend_objects.new(name, data)
                if obj:
                    obj.name = name
                    if callable(setup_callback):
                        setup_callback(obj)
        if obj and create:
            scene_objects.link(obj)
            scene.update()
    return obj


def _get_base(name, scene):
    try:
        return scene.object_bases[name]
    except KeyError:
        scenes = bpy.data.scenes
        for ds in scenes:
            if ds is scene:
                continue
            try:
                return ds.object_bases[name]
            except KeyError:
                continue
    return None


def delete_objects(*args):
    context = bpy.context
    scene = context.scene

    objects = []
    selected_bases = []
    for arg in args:
        if isinstance(arg, (list, tuple, set)):
            for obj in arg:
                if not obj:
                    continue
                objects.append(obj)
                base = _get_base(obj.name, scene)
                if base:
                    selected_bases.append(base)
        else:
            if not arg:
                continue
            objects.append(arg)
            base = _get_base(arg.name, scene)
            if base:
                selected_bases.append(base)

    if not objects:
        return

    window = context.window
    screen = context.screen
    area = context.area
    region = context.region
    edit_object = context.edit_object
    blend_data = context.blend_data

    override = {
        "active_object": objects[0],
        "object": objects[0],
        "selected_objects": objects,
        "selected_bases": selected_bases,
        "edit_object": edit_object,
        "blend_data": blend_data,
        "window": window,
        "screen": screen,
        "area": area,
        "region": region,
        "scene": scene
    }
    bpy.ops.object.delete(override, use_global=True)


def update_scenes(scenes):
    for scene in scenes:
        scene.update()


def get_seamless_area(context, create=False):
    name = SEAMLESS_AREA_NAME

    def setup(obj):
        obj.empty_draw_type = "SINGLE_ARROW"
        obj.lock_scale = [True, True, True]

    obj = get_object(name, context, create, setup)
    return obj


def get_seamless_sub(name, context, create=False):
    def setup(obj):
        obj.hide = True
        obj.hide_select = True
        obj.lock_scale = [True, True, True]

    obj = get_object(name, context, create, setup)
    if obj and not obj.parent:
        obj.parent = get_seamless_area(context, create)
    return obj


def get_seamless_objects(context, create=False):
    return get_seamless_sub(SEAMLESS_OBJECTS_NAME, context, create)


def get_seamless_proxies(context, create=False):
    return get_seamless_sub(SEAMLESS_PROXIES_NAME, context, create)


def get_seamless_margin(context, create=False):
    return get_seamless_sub(SEAMLESS_MARGIN_NAME, context, create)


def get_seamless_camera(context, create=False):
    name = SEAMLESS_CAMERA_NAME

    def setup(obj):
        obj.location[2] = 32.0
        obj.parent = get_seamless_area(context, True)

    def get_camera_data(name, context):
        cameras = bpy.data.cameras
        try:
            data = cameras[name]
        except KeyError:
            data = cameras.new(name)
            data.name = name
        if data:
            data.type = "ORTHO"
        return data

    obj = get_object(name, context, create, setup, get_camera_data)
    return obj


def get_seamless_margin_obj(suffix, context, create=False):
    name = SEAMLESS_MARGIN_NAME + suffix

    def setup(obj):
        obj.lock_scale = [True, True, True]
        obj.draw_type = "WIRE"

    def get_data(name, context):
        meshes = bpy.data.meshes
        data = meshes.new(name)
        data.name = name
        data.from_pydata(
            [
                        (-1, 0, -1),
                        (1, 0, -1),
                        (1, 0, 1),
                        (-1, 0, 1)
            ],
            [],
            [(0, 1, 2, 3)]
        )
        data.update()
        return data

    obj = get_object(name, context, create, setup, get_data)
    if obj:
        obj.parent = get_seamless_margin(context, create)
        if create and not obj.rigid_body:
            obj.hide = False
            obj.hide_select = False
            obj.hide_render = False

            window = context.window
            screen = context.screen
            area = context.area
            region = context.region
            scene = context.scene
            override = {
                "active_object": obj,
                "object": obj,
                "selected_objects": [obj, ],
                "window": window,
                "screen": screen,
                "area": area,
                "region": region,
                "scene": scene
            }
            bpy.ops.rigidbody.objects_add(override, type="PASSIVE")
            rb = obj.rigid_body
            rb.collision_shape = "BOX"
            rb.use_margin = True
            rb.collision_margin = 1.0

            obj.hide = True
            obj.hide_select = True
            obj.hide_render = True

    return obj


def get_seamless_floor_obj(context, create=False):
    name = SEAMLESS_FLOOR_NAME

    def setup(obj):
        obj.lock_scale = [True, True, True]
        obj.draw_type = "WIRE"

    def get_data(name, context):
        meshes = bpy.data.meshes
        data = meshes.new(name)
        data.name = name
        data.from_pydata(
            [
                        (-1, -1, 0),
                        (1, -1, 0),
                        (1, 1, 0),
                        (-1, 1, 0)
            ],
            [],
            [(0, 1, 2, 3)]
        )
        data.update()
        return data

    obj = get_object(name, context, create, setup, get_data)
    if obj:
        obj.parent = get_seamless_area(context, create)
        if create and not obj.rigid_body:
            obj.hide = False
            obj.hide_select = False
            obj.hide_render = False

            window = context.window
            screen = context.screen
            area = context.area
            region = context.region
            scene = context.scene
            override = {
                "active_object": obj,
                "object": obj,
                "selected_objects": [obj, ],
                "window": window,
                "screen": screen,
                "area": area,
                "region": region,
                "scene": scene
            }
            bpy.ops.rigidbody.objects_add(override, type="PASSIVE")
            rb = obj.rigid_body
            rb.collision_shape = "BOX"
            rb.use_margin = True
            rb.collision_margin = 0.5

            obj.hide = True
            obj.hide_select = True
            obj.hide_render = True

    return obj


def copy_rb_settings_to_proxy(obj, proxy):
    rbs = obj.rigid_body
    rbd = proxy.rigid_body

    rbd.type = "PASSIVE"
    rbd.collision_shape = rbs.collision_shape
    rbd.collision_margin = rbs.collision_margin
    rbd.collision_groups[:] = rbs.collision_groups
    rbd.use_margin = rbs.use_margin
    rbd.friction = rbs.friction
    rbd.restitution = rbs.restitution
    rbd.mesh_source = rbs.mesh_source
    rbd.use_deform = rbs.use_deform
    rbd.kinematic = True if rbs.type == "ACTIVE" else rbs.kinematic

# Node Group Updates


def update_node_groups(props, context):
    g = bpy.data.node_groups
    try:
        tx = g["Seamless Transform"].nodes
    except:
        return
    try:
        tx["seamless_tile_x"].outputs[0].default_value = props.tile_x
    except:
        pass
    try:
        tx["seamless_tile_y"].outputs[0].default_value = props.tile_y
    except:
        pass
    sa = get_seamless_area(context)
    if not sa:
        return
    try:
        offset = tx["seamless_area_offset"]
    except:
        pass
    else:
        offset.translation[:] = sa.location
        offset.translation.negate()
    try:
        rot = tx["seamless_area_rotation"]
    except:
        pass
    else:
        rot.rotation[:] = sa.matrix_world.inverted().to_euler()


# Property Updates
def update_camera(self, context):
    camera = get_seamless_camera(context)
    if not camera:
        return

    camera.data.ortho_scale = max(self.tile_x, self.tile_y)

    scene = context.scene

    if self.res_mode == "MIN":
        min_res = self.min_res
        x = round((self.tile_x / self.tile_y) * min_res)
        y = round((self.tile_y / self.tile_x) * min_res)
        if x < y:
            scene.render.resolution_x = min_res
            scene.render.resolution_y = y
        else:
            scene.render.resolution_x = x
            scene.render.resolution_y = min_res
    else:
        max_res = self.max_res
        x = round((self.tile_x / self.tile_y) * max_res)
        y = round((self.tile_y / self.tile_x) * max_res)
        if x < y:
            scene.render.resolution_x = x
            scene.render.resolution_y = max_res
        else:
            scene.render.resolution_x = max_res
            scene.render.resolution_y = y


def update_proxy_location(step, index):
    sp_group = get_sp_group()
    if sp_group:
        sp_objects = sp_group.objects
        for obj in sp_objects:
            loc = obj.get(SEAMLESS_LOC, [])
            if len(loc) != 2:
                continue
            obj.location[index] = step * loc[index]


def update_tile_x(self, context):
    update_camera(self, context)
    update_proxy_location(self.tile_x, 0)
    update_margin(self, context)
    update_node_groups(self, context)


def update_tile_y(self, context):
    update_camera(self, context)
    update_proxy_location(self.tile_y, 1)
    update_margin(self, context)
    update_node_groups(self, context)


def update_margin(self, context):
    use_margin = self.use_margin
    ma = get_seamless_margin_obj("_a", context, use_margin)
    mb = get_seamless_margin_obj("_b", context, use_margin)
    mc = get_seamless_margin_obj("_c", context, use_margin)
    md = get_seamless_margin_obj("_d", context, use_margin)
    if use_margin:
        ma.rotation_euler[2] = 0.0
        mb.rotation_euler[2] = 4.7123891115188598
        mc.rotation_euler[2] = 3.1415927410125732
        md.rotation_euler[2] = 1.5707963705062866

        margin = self.margin
        x = float(self.tile_x)
        y = float(self.tile_y)
        hx = x / 2.0
        hy = y / 2.0
        z = 1024.0

        ma.location[1] = hy + margin
        mb.location[0] = hx + margin
        mc.location[1] = -(hy + margin)
        md.location[0] = -(hx + margin)

        ac = [(-(hx + margin), 0, -z), (hx + margin, 0, -z), (hx + margin, 0, z), (-(hx + margin), 0, z)]
        bd = [(-(hy + margin), 0, -z), (hy + margin, 0, -z), (hy + margin, 0, z), (-(hy + margin), 0, z)]

        for index, vert in enumerate(ma.data.vertices):
            vert.co = Vector(ac[index])

        for index, vert in enumerate(mb.data.vertices):
            vert.co = Vector(bd[index])

        for index, vert in enumerate(mc.data.vertices):
            vert.co = Vector(ac[index])

        for index, vert in enumerate(md.data.vertices):
            vert.co = Vector(bd[index])

        ma.data.update()
        mb.data.update()
        mc.data.update()
        md.data.update()
    else:
        delete_objects(ma, mb, mc, md)

    update_floor(self, context)


def update_floor(self, context):
    use_floor = self.use_floor
    floor_obj = get_seamless_floor_obj(context, use_floor)

    if use_floor:
        floor = self.floor
        margin = self.margin if self.use_margin else 0
        x = float(self.tile_x)
        y = float(self.tile_y)
        hx = x / 2.0
        hy = y / 2.0

        floor_obj.location[2] = floor

        points = [(-(hx + margin), -(hy + margin), 0), (hx + margin, -(hy + margin), 0), (hx + margin, hy + margin, 0), (-(hx + margin), hy + margin, 0)]
        for index, vert in enumerate(floor_obj.data.vertices):
            vert.co = Vector(points[index])

        floor_obj.data.update()
    else:
        delete_objects(floor_obj)

# Operators


class ObjectMode:
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.mode == "OBJECT" and context.space_data.type == "VIEW_3D"


class ObjectModeSeamless:
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.mode == "OBJECT" and context.space_data.type == "VIEW_3D" and get_seamless_area(context)


class Box:

    def __init__(self, width, height, x, y):
        self.hx = width / 2.0
        self.hy = height / 2.0
        self.x = x
        self.y = y

    def __call__(self, box):
        x = abs(self.x - box.x) <= (self.hx + box.hx)
        y = abs(self.y - box.y) <= (self.hy + box.hy)
        return x and y

    def dist(self, box):
        x = abs(self.x - box.x)
        y = abs(self.y - box.y)
        return x, y


class SeamlessProxyManager:

    def sproxy_begin(self, context):
        self._sp_unlink_groups = defaultdict(set)
        self._sp_deletion = set()
        self._sp_link_scenes = defaultdict(set)
        self._sp_link_groups = defaultdict(set)
        self._sp_rb_settings = defaultdict(set)
        self._sp_rb_add = set()
        self._sp_rb_remove = set()
        self._rbg = context.scene.rigidbody_world.group if context.scene.rigidbody_world else None
        props = context.scene.seamless
        margin = props.margin if props.use_margin else 0
        margin *= 2.0
        self._box = Box(props.tile_x + margin, props.tile_y + margin, 0, 0)
        self._box_sa = Box(props.tile_x, props.tile_y, 0, 0)
        self.optimize = props.optimize

    def sproxy_update_object(self, obj, proxy, parent, group, scene, props):
        proxy_objects = group.objects
        scene_objects = scene.objects
        location = proxy.get(SEAMLESS_LOC, [])
        if len(location) != 2:
            raise RuntimeError("Seamless proxy object to be updated has no location information.")

        if proxy.name not in scene_objects:
            self._sp_link_scenes[scene].add(proxy)
        if proxy.name not in proxy_objects:
            self._sp_link_groups[group].add(proxy)
        if proxy.parent != parent:
            proxy.parent = parent

        proxy.location[0] = props.tile_x * location[0]
        proxy.location[1] = props.tile_y * location[1]
        proxy.location[2] = 0

        # Check constraints
        const = proxy.constraints
        # Verify constraints?
        if not const:
            con_scale = const.new("COPY_SCALE")
            con_scale.name = "proxy_scale"
            con_scale.target_space = "LOCAL"
            con_scale.owner_space = "LOCAL"
            con_scale.target = obj
            con_scale.show_expanded = False

            con_rot = const.new("COPY_ROTATION")
            con_rot.name = "proxy_rotation"
            con_rot.target_space = "WORLD"
            con_rot.owner_space = "WORLD"
            con_rot.target = obj
            con_rot.show_expanded = False

            con_loc = const.new("COPY_LOCATION")
            con_loc.name = "proxy_location"
            con_loc.target_space = "LOCAL"
            con_loc.owner_space = "LOCAL"
            con_loc.use_offset = True
            con_loc.target = obj
            con_loc.show_expanded = False

        # Check rigid body
        if obj.rigid_body and not proxy.rigid_body:
            self._sp_rb_settings[obj].add(proxy)
            self._sp_rb_add.add(proxy)
        elif proxy.rigid_body and not obj.rigid_body:
            self._sp_rb_remove.add(proxy)
        elif obj.rigid_body and proxy.rigid_body:
            copy_rb_settings_to_proxy(obj, proxy)

    def sproxy_update(self, obj, proxy_parent, proxy_group, scene, props):
        # Get proxy groups if any
        sproxy_groups = []
        for group in obj.users_group:
            if group.name.startswith(SEAMLESS_PROXY_PREFIX):
                sproxy_groups.append(group)

        # Proxy group selection and preprocessing
        sp_unlink_groups = self._sp_unlink_groups
        sp_group = None
        for group in sproxy_groups:
            gobs = group.objects
            unlinks = sp_unlink_groups[group]
            if sp_group:
                for gob in gobs:
                    if gob == obj:
                        unlinks.add(gob)
                        continue
                    try:
                        target = gob.constraints[0].target
                    except:
                        continue
                    if not target:
                        continue

                    if target == obj:
                        unlinks.add(gob)
            else:
                in_group = []
                out_group = []
                for gob in gobs:
                    if gob == obj:
                        in_group.append(gob)
                        continue
                    try:
                        target = gob.constraints[0].target
                    except:
                        out_group.append(gob)
                        continue
                    if not target:
                        continue

                    if target == obj:
                        in_group.append(gob)
                    else:
                        out_group.append(gob)

                if len(in_group) <= len(out_group):
                    for o in in_group:
                        unlinks.add(o)
                else:
                    for o in out_group:
                        unlinks.add(o)
                    sp_group = group

        # Make a new group if one was not resolved above
        if not sp_group:
            sp_group = bpy.data.groups.new(SEAMLESS_PROXY_GROUP)
            self._sp_link_groups[sp_group].add(obj)

        # Make proxy dict
        gobs = sp_group.objects
        proxies = defaultdict(list)
        for gob in gobs:
            try:
                loc = gob[SEAMLESS_LOC]
            except KeyError:
                continue
            try:
                proxies[tuple(loc)].append(gob)
            except:
                pass

        # Get proxy level
        level = obj.get(SEAMLESS_LEVEL, 1)

        # Get clipping state
        clip = obj.get(SEAMLESS_CLIP, False)
        if obj.rigid_body:
            if obj.rigid_body.type == "ACTIVE":
                clip = False
        if clip or self.optimize:
            matb = obj.matrix_basis
            bb = [matb * Vector(vert) for vert in obj.bound_box]
            bbx_min = bbx_max = bb[0][0]
            bby_min = bby_max = bb[0][1]
            for vert in bb:
                x = vert[0]
                y = vert[1]
                bbx_min = min(bbx_min, x)
                bbx_max = max(bbx_max, x)
                bby_min = min(bby_min, y)
                bby_max = max(bby_max, y)

            bb_w = abs(bbx_max - bbx_min)
            bb_h = abs(bby_max - bby_min)
            bb_x = bbx_min + (bb_w / 2.0)
            bb_y = bby_min + (bb_h / 2.0)

        # Mark duplicate proxies for deletion
        deleted = self._sp_deletion
        for value in proxies.values():
            for i, p in enumerate(value):
                if i > 0:
                    deleted.add(p)

        # Mark out-of-level proxies for deletion
        for key, value in proxies.items():
            if abs(key[0]) > level or abs(key[1]) > level or (key[0] != 0 and not props.use_tile_x) or (key[1] != 0 and not props.use_tile_y):
                for p in value:
                    deleted.add(p)

        # Optimize?
        if self.optimize:
            obj_x, obj_y = self._box_sa.dist(Box(bb_w, bb_h, bb_x, bb_y))
            old_x = obj.location[0]
            old_y = obj.location[1]
            x = -level
            while x <= level:
                y = -level
                while y <= level:
                    if x == 0 and y == 0:
                        y += 1
                        continue
                    proxy = proxies[(x, y)]
                    p_x, p_y = self._box_sa.dist(Box(bb_w, bb_h, bb_x + (props.tile_x * x), bb_y + (props.tile_y * y)))
                    if p_x < obj_x and props.use_tile_x:
                        obj.location[0] = old_x + props.tile_x * x
                    if p_y < obj_y and props.use_tile_y:
                        obj.location[1] = old_y + props.tile_y * y
                    y += 1
                x += 1

            if clip:
                matb = obj.matrix_basis
                bb = [matb * Vector(vert) for vert in obj.bound_box]
                bbx_min = bbx_max = bb[0][0]
                bby_min = bby_max = bb[0][1]
                for vert in bb:
                    x = vert[0]
                    y = vert[1]
                    bbx_min = min(bbx_min, x)
                    bbx_max = max(bbx_max, x)
                    bby_min = min(bby_min, y)
                    bby_max = max(bby_max, y)

                bb_w = abs(bbx_max - bbx_min)
                bb_h = abs(bby_max - bby_min)
                bb_x = bbx_min + (bb_w / 2.0)
                bb_y = bby_min + (bb_h / 2.0)

        # Particle systems?
        use_psys = props.psys
        if hasattr(obj, "particle_systems"):
            obj["skip_psys"] = not use_psys

        # Update proxies
        rbg = self._rbg
        x = -level
        while x <= level:
            y = -level
            while y <= level:
                if x == 0 and y == 0:
                    y += 1
                    continue
                if (x != 0 and not props.use_tile_x) or (y != 0 and not props.use_tile_y):
                    y += 1
                    continue
                proxy = proxies[(x, y)]
                if clip:
                    if not self._box(Box(bb_w, bb_h, bb_x + (props.tile_x * x), bb_y + (props.tile_y * y))):
                        if proxy:
                            deleted.add(proxy[0])
                        y += 1
                        continue
                if proxy:
                    p = proxy[0]
                else:
                    p = obj.copy()
                    p.constraints.clear()
                    p.name = SEAMLESS_PROXY_NAME
                    p[SEAMLESS_LOC] = [x, y]
                    p.select = False
                    p.hide = props.default_hide
                    p.hide_select = props.default_hide_select
                    p.hide_render = props.default_hide_render
                    p.draw_type = props.default_draw_type
                    try:  # *sigh* It really is this simple:
                        p.show_wire_color = True
                        p.color[0] = p.color[1] = p.color[2] = 0.8
                    except:
                        pass  # *double sigh*
                    proxy.append(p)
                    self._sp_link_groups[sp_group].add(p)
                    if p.rigid_body and rbg:
                        self._sp_link_groups[rbg].add(p)

                    # Handle particle systems
                    if use_psys:
                        remove_psys = set()
                        if hasattr(p, "particle_systems"):
                            for pi, ps in enumerate(p.particle_systems):
                                settings = ps.settings
                                if not settings:
                                    continue
                                sps = settings.seamless
                                sps.mode_last = sps.mode
                                if sps.mode == "NONE":
                                    continue
                                elif sps.mode == "REMOVE":
                                    remove_psys.add(ps)
                                    continue
                                elif sps.mode == "LINKED":
                                    ps.settings.use_emit_random = False
                                elif sps.mode == "DUPLICATE":
                                    ps.settings = settings = settings.copy()
                                    settings.name = p.name + ".{0:03d}".format(pi)
                                    settings.seamless.is_proxy = True
                                fc = ps.driver_add("seed")
                                driver = fc.driver
                                driver.type = "SUM"
                                driver_var = driver.variables.new()
                                driver_var.name = ps.name
                                dt = driver_var.targets[0]
                                dt.data_path = "particle_systems[{}].seed".format(pi)
                                dt.id = obj
                        if remove_psys:
                            psys_mods = [mod for mod in p.modifiers if hasattr(mod, "particle_system")]
                            for mod in psys_mods:
                                if mod.particle_system in remove_psys:
                                    p.modifiers.remove(mod)
                    else:
                        if hasattr(obj, "modifiers"):
                            psys_mods = [mod for mod in p.modifiers if hasattr(mod, "particle_system")]
                            for mod in psys_mods:
                                p.modifiers.remove(mod)

                self.sproxy_update_object(obj, p, proxy_parent, proxy_group, scene, props)
                y += 1
            x += 1

    def sproxy_end(self, context):
        sp_link_scenes = self._sp_link_scenes
        for scene, objects in sp_link_scenes.items():
            scene_objects = scene.objects
            for object in objects:
                scene_objects.link(object)
        sp_link_scenes.clear()

        sp_link_groups = self._sp_link_groups
        for group, objects in sp_link_groups.items():
            group_objects = group.objects
            for object in objects:
                group_objects.link(object)
        sp_link_groups.clear()

        sp_unlink_groups = self._sp_unlink_groups
        for group, objects in sp_unlink_groups.items():
            group_objects = group.objects
            for object in objects:
                group_objects.unlink(object)
        sp_unlink_groups.clear()

        delete_objects(self._sp_deletion)
        self._sp_deletion.clear()

        sp_rb_add = list(self._sp_rb_add)
        sp_rb_add_hide = [object.hide for object in sp_rb_add]
        for object in sp_rb_add:
            object.hide = False
        if sp_rb_add:
            window = context.window
            screen = context.screen
            area = context.area
            region = context.region
            scene = context.scene
            override = {
                "active_object": sp_rb_add[0],
                "object": sp_rb_add[0],
                "selected_objects": sp_rb_add,
                "window": window,
                "screen": screen,
                "area": area,
                "region": region,
                "scene": scene
            }
            bpy.ops.rigidbody.objects_add(override, type="PASSIVE")
        for index, object in enumerate(sp_rb_add):
            object.hide = sp_rb_add_hide[index]
        self._sp_rb_add.clear()
        sp_rb_add.clear()

        sp_rb_settings = self._sp_rb_settings
        for object, proxies in sp_rb_settings.items():
            for proxy in proxies:
                copy_rb_settings_to_proxy(object, proxy)
        sp_rb_settings.clear()

        sp_rb_remove = list(self._sp_rb_remove)
        if sp_rb_remove:
            window = context.window
            screen = context.screen
            area = context.area
            region = context.region
            scene = context.scene
            override = {
                "active_object": sp_rb_remove[0],
                "object": sp_rb_remove[0],
                "selected_objects": sp_rb_remove,
                "window": window,
                "screen": screen,
                "area": area,
                "region": region,
                "scene": scene
            }
            bpy.ops.rigidbody.objects_remove(override)
        self._sp_rb_remove.clear()
        sp_rb_remove.clear()

        particles = bpy.data.particles
        sp_psys_remove = [p for p in particles if not p.users and p.seamless.is_proxy]
        for p in sp_psys_remove:
            particles.remove(p)


class SeamlessOperator_Add(Operator, ObjectMode, SeamlessProxyManager):
    """Add selected objects to the seamless area."""
    bl_idname = "seamless.add"
    bl_label = "Add Seamless"

    def execute(self, context):
        selected = context.selected_objects
        if not selected:
            self.report({'WARNING'}, "Nothing selected!")
            return {'CANCELLED'}

        scene = context.scene
        props = scene.seamless
        wm = context.window_manager

        s_obj = get_seamless_objects(context, True)
        s_prox = get_seamless_proxies(context, True)
        so_group = get_so_group(True)
        sp_group = get_sp_group(True)

        update_margin(props, context)

        seamless_objects = so_group.objects
        self.sproxy_begin(context)
        so_links = self._sp_link_groups[so_group]

        count = 0
        total = len(selected)

        wm.progress_begin(0, total)
        for obj in selected:
            count += 1
            wm.progress_update(count)
            name = obj.name

            # obj is not a managed object
            if name.startswith("~"):
                continue

            # obj is not a camera
            if obj.type == "CAMERA":
                continue

            # obj is not a proxy (in case proxy does not start with ~)
            try:
                _loc = obj[SEAMLESS_LOC]
            except KeyError:
                pass
            else:
                continue

            # Put in seamless objects group
            if name not in seamless_objects:
                so_links.add(obj)

            # Parent to seamless objects
            if obj.parent != s_obj:
                obj.matrix_world = s_obj.matrix_world.inverted() * obj.matrix_world
                obj.parent = s_obj

            # Assign proxy level
            obj[SEAMLESS_LEVEL] = props.level

            # Assign clipping state
            obj[SEAMLESS_CLIP] = props.clip

            # Update proxies
            self.sproxy_update(obj, s_prox, sp_group, scene, props)

        self.sproxy_end(context)
        wm.progress_end()
        return {'FINISHED'}


class SeamlessOperator_Remove(Operator, ObjectModeSeamless, SeamlessProxyManager):
    """Remove selected objects from the seamless area."""
    bl_idname = "seamless.remove"
    bl_label = "Remove Seamless"

    def execute(self, context):
        selected = context.selected_objects
        if not selected:
            self.report({'WARNING'}, "Nothing selected!")
            return {'CANCELLED'}
        self.sproxy_begin(context)

        sp_deletion = self._sp_deletion
        sp_unlink_groups = self._sp_unlink_groups

        so_group = get_so_group()

        for obj in selected:
            # obj is not a proxy
            try:
                _loc = obj[SEAMLESS_LOC]
            except KeyError:
                pass
            else:
                continue

            if so_group:
                if obj.name in so_group.objects:
                    sp_unlink_groups[so_group].add(obj)

            sproxy_groups = []
            for group in obj.users_group:
                if group.name.startswith(SEAMLESS_PROXY_PREFIX):
                    sproxy_groups.append(group)
            for group in sproxy_groups:
                gobs = group.objects
                for gob in gobs:
                    if gob == obj:
                        continue
                    try:
                        target = gob.constraints[0].target
                    except:
                        continue
                    if not target:
                        continue
                    if target == obj:
                        sp_deletion.add(gob)

            groups = bpy.data.groups
            for group in sproxy_groups:
                groups.remove(group)

            if obj.parent:
                mat = obj.matrix_world
                if obj.parent.name == SEAMLESS_OBJECTS_NAME:
                    obj.parent = None
                obj.matrix_world = mat

        self.sproxy_end(context)
        return {'FINISHED'}


class SeamlessOperator_Refresh(Operator, ObjectModeSeamless, SeamlessProxyManager):
    """Refresh all seamless objects and dependencies."""
    bl_idname = "seamless.refresh"
    bl_label = "Refresh Seamless"

    selected = BoolProperty(
        name="Selected",
        description="Only refresh selected seamless objects.",
        default=False
    )

    def execute(self, context):
        so_group = get_so_group()
        if not so_group:
            return {'CANCELLED'}

        seamless_objects = so_group.objects

        self.sproxy_begin(context)
        scene = context.scene
        props = scene.seamless
        wm = context.window_manager

        s_obj = get_seamless_objects(context, True)
        s_prox = get_seamless_proxies(context, True)
        sp_group = get_sp_group(True)

        sp_deletion = self._sp_deletion
        seamless_proxies = sp_group.objects
        count = 0
        total = len(seamless_proxies)

        wm.progress_begin(0, total)
        for obj in seamless_proxies:
            count += 1
            wm.progress_update(count)

            try:
                target = obj.constraints[0].target
            except:
                sp_deletion.add(obj)
                continue

            if target:
                valid_sproxy = False
                for group in obj.users_group:
                    if group.name.startswith(SEAMLESS_PROXY_PREFIX):
                        valid_sproxy = True
                        break
                if not valid_sproxy:
                    sp_deletion.add(obj)
            else:
                sp_deletion.add(obj)

        if self.selected:
            seamless_objects = [obj for obj in seamless_objects if obj.select]

        wm.progress_end()
        count = 0
        total = len(seamless_objects)
        wm.progress_begin(0, total)
        for obj in seamless_objects:
            count += 1
            wm.progress_update(count)
            name = obj.name

            # obj is not a managed object
            if name.startswith("~"):
                continue

            # obj is not a camera
            if obj.type == "CAMERA":
                continue

            # obj is not a proxy (in case proxy does not start with ~)
            try:
                _loc = obj[SEAMLESS_LOC]
            except KeyError:
                pass
            else:
                continue

            # Parent to seamless objects
            if obj.parent != s_obj:
                obj.matrix_world = s_obj.matrix_world.inverted() * obj.matrix_world
                obj.parent = s_obj

            # Update proxies
            self.sproxy_update(obj, s_prox, sp_group, scene, props)

        self.sproxy_end(context)
        wm.progress_end()

        return {'FINISHED'}


class SeamlessOperator_Select(Operator, ObjectModeSeamless):
    """Select all seamless objects."""
    bl_idname = "seamless.select"
    bl_label = "Select Seamless"

    extend = BoolProperty(
        name="Extend",
        description="Extend existing selection.",
        default=True
    )

    def execute(self, context):
        so_group = get_so_group()
        if not so_group:
            return {'CANCELLED'}

        seamless_objects = so_group.objects
        if len(seamless_objects) < 1:
            return {'CANCELLED'}

        if not self.extend:
            bpy.ops.object.select_all(action="DESELECT")

        for obj in seamless_objects:
            obj.select = True

        return {'FINISHED'}


class SeamlessOperator_Deselect(Operator, ObjectModeSeamless):
    """Deselect seamless objects."""
    bl_idname = "seamless.deselect"
    bl_label = "Deselect Seamless"

    def execute(self, context):
        so_group = get_so_group()
        if not so_group:
            return {'CANCELLED'}

        seamless_objects = so_group.objects
        if len(seamless_objects) < 1:
            return {'CANCELLED'}

        for obj in seamless_objects:
            obj.select = False

        return {'FINISHED'}


class SeamlessOperator_InvertSelection(Operator, ObjectModeSeamless):
    """Invert selection of seamless objects."""
    bl_idname = "seamless.invert_selection"
    bl_label = "Invert Seamless Selection"

    def execute(self, context):
        so_group = get_so_group()
        if not so_group:
            return {'CANCELLED'}

        seamless_objects = so_group.objects
        if len(seamless_objects) < 1:
            return {'CANCELLED'}

        for obj in seamless_objects:
            obj.select = not obj.select

        return {'FINISHED'}


class SeamlessOperator_SelectSeamlessArea(Operator, ObjectModeSeamless):
    """Selects the seamless area (the root object for all that is seamless)"""
    bl_idname = "seamless.select_area"
    bl_label = "Select Seamless Area"

    def execute(self, context):
        sa = get_seamless_area(context)
        if not sa:
            self.report({'WARNING'}, "Seamless area not found!")
            return {'CANCELLED'}

        bpy.ops.object.select_all(action="DESELECT")
        sa.select = True
        context.scene.objects.active = sa

        return {'FINISHED'}


class SeamlessOperator_CursorToSeamlessArea(Operator, ObjectModeSeamless):
    """Snap 3D cursor to seamless area."""
    bl_idname = "seamless.cursor_to_seamless"
    bl_label = "Cursor to Seamless Area"

    def execute(self, context):
        sa = get_seamless_area(context)
        if not sa:
            self.report({'WARNING'}, "Seamless area not found!")
            return {'CANCELLED'}

        bpy.context.space_data.cursor_location[:] = sa.matrix_world.translation

        return {'FINISHED'}


class SeamlessOperator_ApplyVisualTransform(Operator, ObjectModeSeamless):
    """Apply visual transform of seamless objects."""
    bl_idname = "seamless.apply_visual_transform"
    bl_label = "Apply Seamless Visual Transform"

    selected = BoolProperty(
        name="Selected",
        description="Only apply visual transform to selected seamless objects.",
        default=False
    )

    def execute(self, context):
        so_group = get_so_group()
        if not so_group:
            return {'CANCELLED'}

        seamless_objects = so_group.objects
        if self.selected:
            seamless_objects = [obj for obj in seamless_objects if obj.select]
        if len(seamless_objects) < 1:
            return {'CANCELLED'}

        window = context.window
        screen = context.screen
        area = context.area
        region = context.region
        scene = context.scene
        override = {
            "active_object": seamless_objects[0],
            "object": seamless_objects[0],
            "selected_objects": seamless_objects,
            "selected_editable_objects": seamless_objects,
            "window": window,
            "screen": screen,
            "area": area,
            "region": region,
            "scene": scene
        }
        bpy.ops.object.visual_transform_apply(override)

        return {'FINISHED'}


class SeamlessOperator_ActiveToPassive(Operator, ObjectModeSeamless):
    """Change any active rigid body seamless objects to passive."""
    bl_idname = "seamless.active_to_passive"
    bl_label = "Active Seamless to Passive"

    selected = BoolProperty(
        name="Selected",
        description="Only convert selected active seamless objects to passive.",
        default=False
    )

    def execute(self, context):
        so_group = get_so_group()
        if not so_group:
            return {'CANCELLED'}

        seamless_objects = so_group.objects
        if self.selected:
            seamless_objects = [obj for obj in seamless_objects if obj.select]
        if len(seamless_objects) < 1:
            return {'CANCELLED'}

        for obj in seamless_objects:
            if obj.rigid_body:
                obj.rigid_body.type = "PASSIVE"
            else:
                continue

            sproxy_groups = []
            for group in obj.users_group:
                if group.name.startswith(SEAMLESS_PROXY_PREFIX):
                    sproxy_groups.append(group)

            for group in sproxy_groups:
                for proxy in group.objects:
                    if proxy == obj or not proxy.name.startswith("~"):
                        continue
                    if obj.rigid_body and proxy.rigid_body:
                        copy_rb_settings_to_proxy(obj, proxy)

        return {'FINISHED'}


class SeamlessOperator_Clip(Operator, ObjectModeSeamless, SeamlessProxyManager):
    """Set clipping state of seamless objects."""
    bl_idname = "seamless.clip"
    bl_label = "Set Seamless Clipping"

    selected = BoolProperty(
        name="Selected",
        description="Only set clip state of selected seamless objects.",
        default=False
    )

    clip = BoolProperty(
        name="Clip",
        description="Enable clipping on seamless objects.",
        default=True
    )

    def execute(self, context):
        so_group = get_so_group()
        if not so_group:
            return {'CANCELLED'}

        seamless_objects = so_group.objects
        if len(seamless_objects) < 1:
            return {'CANCELLED'}

        self.sproxy_begin(context)
        scene = context.scene
        props = scene.seamless
        wm = context.window_manager

        s_obj = get_seamless_objects(context, True)
        s_prox = get_seamless_proxies(context, True)
        sp_group = get_sp_group(True)

        if self.selected:
            seamless_objects = [obj for obj in seamless_objects if obj.select]

        count = 0
        total = len(seamless_objects)

        wm.progress_begin(0, total)
        for obj in seamless_objects:
            count += 1
            wm.progress_update(count)
            name = obj.name

            # obj is not a managed object
            if name.startswith("~"):
                continue

            # obj is not a camera
            if obj.type == "CAMERA":
                continue

            # obj is not a proxy (in case proxy does not start with ~)
            try:
                _loc = obj[SEAMLESS_LOC]
            except KeyError:
                pass
            else:
                continue

            # Parent to seamless objects
            if obj.parent != s_obj:
                obj.matrix_parent_inverse = s_obj.matrix_world.inverted()
                obj.parent = s_obj

            # Set clipping
            obj[SEAMLESS_CLIP] = self.clip

            # Update proxies
            self.sproxy_update(obj, s_prox, sp_group, scene, props)

        self.sproxy_end(context)
        wm.progress_end()
        return {'FINISHED'}


class SeamlessOperator_Compile(Operator, ObjectModeSeamless, SeamlessProxyManager):
    """Compile seamless objects into a static form or single mesh."""
    bl_idname = "seamless.compile"
    bl_label = "Compile Seamless Objects"

    def compile_mesh_layers(self, meshes, props):
        m_rand_vc_a = props.compile_mesh_random_vcol_a
        m_rand_vc_a_name = props.compile_mesh_random_vcol_a_name
        m_rand_vc_b = props.compile_mesh_random_vcol_b
        m_rand_vc_b_name = props.compile_mesh_random_vcol_b_name
        m_rand_uv = props.compile_mesh_random_uv
        m_rand_uv_name = props.compile_mesh_random_uv_name
        m_loc_uv = props.compile_mesh_location_uv
        m_loc_uv_name = props.compile_mesh_location_uv_name
        m_loc_uv_name_2 = props.compile_mesh_location_uv_name_2
        m_loc_uv_ch = props.compile_mesh_location_uv_ch
        m_loc_uv_4m = props.compile_mesh_location_uv_4m
        m_obj_uv = props.compile_mesh_object_uv
        m_obj_uv_name = props.compile_mesh_object_uv_name
        m_obj_uv_name_2 = props.compile_mesh_object_uv_name_2
        m_obj_uv_rot = props.compile_mesh_object_uv_rot
        m_obj_uv_ch = props.compile_mesh_object_uv_ch
        m_obj_uv_4m = props.compile_mesh_object_uv_4m

        if not m_rand_vc_a + m_rand_vc_b + m_rand_uv + m_loc_uv + m_obj_uv:
            return

        for obj in meshes:
            if obj.data.users > 1:
                obj.data = obj.data.copy()

        seed()

        if m_rand_vc_a:
            for obj in meshes:
                vc = obj.data.vertex_colors
                try:
                    vc_data = vc[m_rand_vc_a_name].data
                except:
                    vc_data = vc.new(m_rand_vc_a_name).data
                if not vc_data:
                    continue
                color = [random(), random(), random()]
                for loop in vc_data:
                    loop.color[:] = color

        if m_rand_vc_b:
            for obj in meshes:
                vc = obj.data.vertex_colors
                try:
                    vc_data = vc[m_rand_vc_b_name].data
                except:
                    vc_data = vc.new(m_rand_vc_b_name).data
                if not vc_data:
                    continue
                color = [random(), random(), random()]
                for loop in vc_data:
                    loop.color[:] = color

        if m_rand_uv:
            for obj in meshes:
                uv = obj.data.uv_layers
                try:
                    uv_data = uv[m_rand_uv_name].data
                except:
                    obj.data.uv_textures.new(m_rand_uv_name)
                    uv_data = uv[m_rand_uv_name].data
                if not uv_data:
                    continue
                values = [random(), random()]
                for loop in uv_data:
                    loop.uv[:] = values

        if m_loc_uv:
            for index, obj in enumerate(meshes):
                uv = obj.data.uv_layers
                try:
                    uv_data = uv[m_loc_uv_name].data
                except:
                    obj.data.uv_textures.new(m_loc_uv_name)
                    uv_data = uv[m_loc_uv_name].data
                if not uv_data:
                    continue
                values = [obj.location[0], obj.location[1]]
                for loop in uv_data:
                    loop.uv[:] = values

                if m_loc_uv_ch != "4":
                    continue

                try:
                    uv_data = uv[m_loc_uv_name_2].data
                except:
                    obj.data.uv_textures.new(m_loc_uv_name_2)
                    uv_data = uv[m_loc_uv_name_2].data
                if not uv_data:
                    continue

                values = [obj.location[2], random() if m_loc_uv_4m == "RANDOM" else index]
                for loop in uv_data:
                    loop.uv[:] = values

        if m_obj_uv:
            for index, obj in enumerate(meshes):
                uv = obj.data.uv_layers
                try:
                    uv_data = uv[m_obj_uv_name].data
                except:
                    obj.data.uv_textures.new(m_obj_uv_name)
                    uv_data = uv[m_obj_uv_name].data
                if not uv_data:
                    continue

                scale = obj.scale
                verts = [Vector((v.co[0] * scale[0], v.co[1] * scale[1], v.co[2] * scale[2])) for v in obj.data.vertices]
                if m_obj_uv_rot:
                    quat = obj.matrix_world.to_quaternion()
                    verts = [quat * v for v in verts]

                loops = obj.data.loops
                for i, loop in enumerate(uv_data):
                    loop.uv[:] = verts[loops[i].vertex_index][:2]

                if m_obj_uv_ch != "4":
                    continue

                try:
                    uv_data = uv[m_obj_uv_name_2].data
                except:
                    obj.data.uv_textures.new(m_obj_uv_name_2)
                    uv_data = uv[m_obj_uv_name_2].data
                if not uv_data:
                    continue

                value = random() if m_obj_uv_4m == "RANDOM" else index
                for i, loop in enumerate(uv_data):
                    loop.uv[:] = [verts[loops[i].vertex_index][2], value]

    def compile_mesh(self, context, props, objects, parent, name):
        m_convert = props.compile_mesh_convert
        window = context.window
        screen = context.screen
        area = context.area
        region = context.region
        scene = context.scene
        blend_data = context.blend_data
        if m_convert:
            selected_editable_bases = [scene.object_bases[obj.name] for obj in objects]
            override = {
                "active_object": objects[0],
                "object": objects[0],
                "selected_objects": objects,
                "window": window,
                "screen": screen,
                "area": area,
                "region": region,
                "scene": scene,
                "blend_data": blend_data,
                "selected_editable_bases": selected_editable_bases
            }
            old = objects[0].select
            objects[0].select = True  # active object has to have select True or poll fails...
            # Meanwhile, selected objects for context override don't need select to be True? WTF?
            bpy.ops.object.convert(override, target="MESH", keep_original=False)
            objects[0].select = old

        meshes = [obj for obj in objects if obj.type == "MESH" and obj.dupli_type == "NONE"]
        if not meshes:
            return None

        self.compile_mesh_layers(meshes, props)

        def setup(obj):
            obj.parent = parent

        def get_data(name, context):
            meshes = bpy.data.meshes
            data = meshes.new(name)
            data.update()
            return data

        mesh_main = get_object(name, context, True, setup, get_data)
        if not mesh_main:
            return None

        meshes.append(mesh_main)
        selected_editable_bases = [scene.object_bases[obj.name] for obj in meshes]
        override = {
            "active_object": mesh_main,
            "object": mesh_main,
            "selected_objects": meshes,
            "window": window,
            "screen": screen,
            "area": area,
            "region": region,
            "scene": scene,
            "blend_data": blend_data,
            "selected_editable_bases": selected_editable_bases
        }
        bpy.ops.object.join(override)
        return mesh_main

    def execute(self, context):
        s_obj = get_seamless_objects(context)
        if not s_obj:
            return {'CANCELLED'}
        seamless_objects = s_obj.children
        if len(seamless_objects) < 1:
            return {'CANCELLED'}

        scene = context.scene
        props = scene.seamless
        self.sproxy_begin(context)

        sp_deletion = self._sp_deletion
        sp_unlink_groups = self._sp_unlink_groups
        sp_link_groups = self._sp_link_groups
        so_group = get_so_group()
        sp_group = get_sp_group()

        c_type = props.compile_type
        c_name = props.compile_name
        c_cleanup = props.compile_cleanup
        c_clear_rb = props.compile_clear_rb
        c_reinsert = props.compile_reinsert
        c_layers = props.compile_layers
        m_group = props.compile_mesh_group
        m_all = props.compile_mesh_all

        self.mesh_object = None
        self.group = None

        if c_type == "MESH":
            self.mesh_object = self.compile_mesh(context, props, seamless_objects, s_obj, c_name)
            if not self.mesh_object:
                self.report({'WARNING'}, "No seamless mesh objects to compile!")
                return {'CANCELLED'}
            self.mesh_object.parent = None
            if True in c_layers:
                self.mesh_object.layers[:] = c_layers

        seamless_objects = s_obj.children
        if c_type == "GROUP" or m_group:
            if c_type == "MESH" and not m_all:
                objects = [self.mesh_object]
            else:
                objects = list(seamless_objects)
                if self.mesh_object:
                    objects.append(self.mesh_object)

            if len(objects) < 1:
                self.report({'WARNING'}, "No seamless objects to compile!")
                return {'CANCELLED'}

            group = get_group(c_name, True)
            group_objects = group.objects
            self.group = group

            if not c_cleanup:
                for obj in objects:
                    for g in obj.users_group:
                        if g.name.startswith("~"):
                            sp_unlink_groups[g].add(obj)

            group_set = sp_link_groups[group]
            sp_rb_remove = self._sp_rb_remove
            assign_layers = True in c_layers
            for obj in objects:
                group_set.add(obj)
                obj.parent = None
                if c_clear_rb:
                    if obj.rigid_body:
                        sp_rb_remove.add(obj)
                if assign_layers:
                    obj.layers[:] = c_layers

        if c_cleanup:
            for proxy in sp_group.objects:
                sp_deletion.add(proxy)

            for obj in seamless_objects:
                obj.parent = None
        else:
            for proxy in sp_group.objects:
                try:
                    target = proxy.constraints[0].target
                except:
                    sp_deletion.add(proxy)
                    continue
                if target:
                    if target.parent != s_obj:
                        sp_deletion.add(proxy)
                else:
                    sp_deletion.add(proxy)

        if c_reinsert and not c_cleanup:
            s_prox = get_seamless_proxies(context, True)
            ri_object = None
            if self.group:
                def setup(obj):
                    obj.dupli_type = "GROUP"
                    obj.dupli_group = self.group

                ri_object = get_object(c_name + "_group_inst", context, True, setup)
            elif self.mesh_object:
                ri_object = self.mesh_object
                for index, value in enumerate(s_obj.layers):
                    if value:
                        ri_object.layers[index] = True

            if ri_object:
                scene.update()
                sp_link_groups[so_group].add(ri_object)
                ri_object.parent = s_obj
                ri_object[SEAMLESS_LEVEL] = props.level
                ri_object[SEAMLESS_CLIP] = False
                self.sproxy_update(ri_object, s_prox, sp_group, scene, props)

        self.sproxy_end(context)

        if self.group:
            for obj in self.group.objects:
                obj.location = obj.location

        if c_cleanup:
            groups = bpy.data.groups
            if so_group:
                groups.remove(so_group)
            if sp_group:
                groups.remove(sp_group)

            spgs = []
            for group in groups:
                if group.name.startswith(SEAMLESS_PROXY_PREFIX):
                    spgs.append(group)

            for group in spgs:
                groups.remove(group)

            objects = bpy.data.objects
            seamless_system_objects = [obj for obj in objects if obj.name.startswith("~seamless")]
            delete_objects(seamless_system_objects)

        return {'FINISHED'}


def _remove_all(self, context):
    self.sproxy_begin(context)

    sp_deletion = self._sp_deletion
    sp_unlink_groups = self._sp_unlink_groups

    so_group = get_so_group()
    sp_group = get_sp_group()

    if sp_group:
        sp_objects = sp_group.objects
        for obj in sp_objects:
            sp_deletion.add(obj)

    groups = bpy.data.groups
    if so_group:
        groups.remove(so_group)
    if sp_group:
        groups.remove(sp_group)

    spgs = []
    for group in groups:
        if group.name.startswith(SEAMLESS_PROXY_PREFIX):
            spgs.append(group)

    for group in spgs:
        groups.remove(group)

    s_obj = get_seamless_objects(context)
    if s_obj:
        children = list(s_obj.children)
        for obj in children:
            mat = obj.matrix_world
            obj.parent = None
            obj.matrix_world = mat

    self.sproxy_end(context)


class SeamlessOperator_RemoveAll(Operator, ObjectModeSeamless, SeamlessProxyManager):
    """Remove all objects from seamless area."""
    bl_idname = "seamless.remove_all"
    bl_label = "Remove All Seamless"

    def execute(self, context):
        _remove_all(self, context)
        return {'FINISHED'}


class SeamlessOperator_Cleanup(Operator, ObjectModeSeamless, SeamlessProxyManager):
    """Remove all objects from seamless area and remove seamless area."""
    bl_idname = "seamless.cleanup"
    bl_label = "Cleanup Seamless"

    def execute(self, context):
        _remove_all(self, context)
        so_group = get_so_group()
        sp_group = get_sp_group()
        groups = bpy.data.groups
        if so_group:
            groups.remove(so_group)
        if sp_group:
            groups.remove(sp_group)

        spgs = []
        for group in groups:
            if group.name.startswith(SEAMLESS_PROXY_PREFIX):
                spgs.append(group)

        for group in spgs:
            groups.remove(group)

        objects = bpy.data.objects
        seamless_system_objects = [obj for obj in objects if obj.name.startswith("~seamless")]
        delete_objects(seamless_system_objects)
        return {'FINISHED'}


class SeamlessOperator_SetProxyVisibility(Operator, ObjectModeSeamless):
    """Set proxy visibility."""
    bl_idname = "seamless.set_proxy_vis"
    bl_label = "Set Seamless Proxy Visibility"

    selected = BoolProperty(
        name="Selected",
        description="Only set clip state of selected seamless objects.",
        default=False
    )

    def execute(self, context):
        p_obj = get_seamless_proxies(context)
        proxies = p_obj.children
        if self.selected:
            _selprox = []
            for proxy in proxies:
                try:
                    target = proxy.constraints[0].target
                except:
                    continue
                if target.select:
                    _selprox.append(proxy)
            proxies = _selprox
        if len(proxies) < 1:
            return {'CANCELLED'}

        props = context.scene.seamless
        for proxy in proxies:
            proxy.hide = props.vis_hide
            proxy.hide_select = props.vis_hide_select
            proxy.hide_render = props.vis_hide_render
            proxy.draw_type = props.vis_draw_type
        return {'FINISHED'}


class SeamlessOperator_CreateCamera(Operator, ObjectMode):
    """Create a camera linked to the seamless area."""
    bl_idname = "seamless.create_camera"
    bl_label = "Create Seamless Camera"

    @classmethod
    def poll(cls, context):
        return not bool(get_seamless_camera(context)) and ObjectMode.poll(context)

    def execute(self, context):
        sc = get_seamless_camera(context, True)
        if not sc:
            return {'CANCELLED'}

        props = context.scene.seamless
        update_camera(props, context)
        context.scene.camera = sc

        return {'FINISHED'}


class SeamlessOperator_DeleteCamera(Operator, ObjectMode):
    """Delete the camera linked to the seamless area."""
    bl_idname = "seamless.delete_camera"
    bl_label = "Delete Seamless Camera"

    @classmethod
    def poll(cls, context):
        return bool(get_seamless_camera(context)) and ObjectMode.poll(context)

    def execute(self, context):
        sc = get_seamless_camera(context)
        if not sc:
            return {'CANCELLED'}

        delete_objects(sc)

        return {'FINISHED'}


class SeamlessOperator_FlipCamera(Operator, ObjectMode):
    """Flip the camera linked to the seamless area."""
    bl_idname = "seamless.flip_camera"
    bl_label = "Flip Seamless Camera"

    @classmethod
    def poll(cls, context):
        return bool(get_seamless_camera(context)) and ObjectMode.poll(context)

    def execute(self, context):
        sc = get_seamless_camera(context)
        if not sc:
            return {'CANCELLED'}

        if sc.location[2] >= 0:
            sc.location[2] = -sc.location[2]
            sc.rotation_euler[1] = 3.1415927410125732
        else:
            sc.location[2] = -sc.location[2]
            sc.rotation_euler[1] = 0.0

        return {'FINISHED'}


class SeamlessOperator_ResetCamera(Operator, ObjectMode):
    """Reset the camera linked to the seamless area."""
    bl_idname = "seamless.reset_camera"
    bl_label = "Reset Seamless Camera"

    @classmethod
    def poll(cls, context):
        return bool(get_seamless_camera(context)) and ObjectMode.poll(context)

    def execute(self, context):
        sc = get_seamless_camera(context)
        if not sc:
            return {'CANCELLED'}

        sc.location[0] = 0.0
        sc.location[1] = 0.0
        sc.location[2] = 32.0
        sc.rotation_euler[0] = 0.0
        sc.rotation_euler[1] = 0.0
        sc.rotation_euler[2] = 0.0
        sc.data.type = "ORTHO"

        props = context.scene.seamless
        update_camera(props, context)

        return {'FINISHED'}


class SeamlessOperator_ViewDocs(Operator):
    """View seamless tools documentation."""
    bl_idname = "seamless.view_docs"
    bl_label = "View Seamless Tools Documentation"
    bl_options = {'REGISTER'}

    def execute(self, context):
        from os import path
        import webbrowser as wb
        wb.open("file:///" + path.join(path.dirname(__file__), "readme.html"))
        return {'FINISHED'}


class SeamlessOperator_LoadNodeGroups(Operator):
    """Load seamless node groups."""
    bl_idname = "seamless.load_node_groups"
    bl_label = "Load Seamless Node Groups"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        unpack_node_groups()
        update_node_groups(context.scene.seamless, context)
        return {'FINISHED'}


class SeamlessOperator_RefreshNodeGroups(Operator):
    """Refresh seamless node groups."""
    bl_idname = "seamless.refresh_node_groups"
    bl_label = "Refresh Seamless Node Groups"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        update_node_groups(context.scene.seamless, context)
        return {'FINISHED'}


class SeamlessOperator_RefreshParticleSystem(Operator):
    """Refresh particle system because driven seed value does not update particle locations and locations are not updated when adding to seamless area."""
    bl_idname = "seamless.refresh_particle_system"
    bl_label = "Refresh Particle System"
    bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}

    count = IntProperty(default=-1)
    distribution = StringProperty(default="")

    def execute(self, context):
        psys = context.particle_system
        if not psys:
            return
        settings = psys.settings
        if not settings:
            return
        settings.distribution = settings.distribution if not self.distribution else self.distribution
        settings.count = settings.count if self.count < 0 else self.count

        return {'FINISHED'}


class SeamlessOperator_RefreshProxyParticleSystem(Operator):
    """Refresh particle system because driven seed value does not update particle locations and locations are sometimes not updated when adding to seamless area."""
    bl_idname = "seamless.refresh_proxy_particle_system"
    bl_label = "Refresh Proxy Particle System"
    bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}

    def execute(self, context):
        def close(f1, f2):
            return abs(f1 - f2) <= abs(f1) * 1e-5

        psys = context.particle_system
        if not psys:
            return
        settings = psys.settings
        if not settings:
            return
        settings.distribution = settings.distribution
        settings.count = settings.count
        num = settings.count
        dist = settings.distribution

        # Check for duplicates
        ob = context.object
        index = ob.particle_systems.active_index
        sprox = [g.objects for g in ob.users_group if g.name.startswith(SEAMLESS_PROXY_PREFIX)]
        if sprox:
            for proxy in sprox[0]:
                try:
                    psys = proxy.particle_systems[index]
                except:
                    continue
                window = context.window
                screen = context.screen
                area = context.area
                region = context.region
                scene = context.scene
                blend_data = context.blend_data
                override = {
                    "active_object": ob,
                    "object": ob,
                    "particle_system": psys,
                    "window": window,
                    "screen": screen,
                    "area": area,
                    "region": region,
                    "scene": scene,
                    "blend_data": blend_data,
                }
                bpy.ops.seamless.refresh_particle_system(override, count=num, distribution=dist)

        return {'FINISHED'}

# Scene Properties
ei_res_mode = (
    ("MIN", "Min", "Use minimum resolution."),
    ("MAX", "Max", "Use maximum resolution.")
)

ei_draw_type = (
    ("TEXTURED", "Textured", "Textured viewport shading.", "POTATO", 0),
    ("SOLID", "Solid", "Solid viewport shading.", "SOLID", 1),
    ("WIRE", "Wire", "Wire viewport drawing.", "WIRE", 2),
    ("BOUNDS", "Bounds", "Bounding box viewport drawing.", "BBOX", 3),
)

ei_compile_type = (
    ("GROUP", "Group", "Compile seamless objects to a group.", "GROUP", 0),
    ("MESH", "Mesh", "Compile compatible seamless objects to a single mesh.", "OUTLINER_OB_MESH", 1),
)

ei_uv_type = (
    ("2", "2 Channel", "Use a single UV layer (Z is excluded)."),
    ("4", "4 Channel", "Use two UV layers.")
)

ei_uv_fourth = (
    ("RANDOM", "Random", "Random value per object ranging from 0.0 to 1.0."),
    ("UNIQUE", "Unique", "Unique value per object starting at 0 incrementing by 1 each time.")
)

ei_psys_mode = (
    ("NONE", "None", "No action is taken. No drivers are created for the seed value.", "DOT", 0),
    ("REMOVE", "Remove", "Particle systems are removed from seamless proxies.", "CANCEL", 1),
    ("LINKED", "Linked", "Random element order is turned off. Seeds are connected with drivers.", "PARTICLES", 2),
    ("DUPLICATE", "Duplicate", "Particle settings are duplicated for each seamless proxy. Seeds are connected with drivers. NOTE: Use this if you want to keep random element order. Other caveats apply. See documentation.", "MOD_PARTICLES", 3),
)

uperf = None


class SeamlessSceneProps(PropertyGroup):

    @classmethod
    def register(cls):
        bpy.types.Scene.seamless = PointerProperty(
            name="Seamless Scene Properties",
            description="Per scene seamless area and tool settings.",
            type=cls,
        )

    @classmethod
    def unregister(cls):
        try:
            del bpy.types.Scene.seamless
        except:
            pass

    tile_x = IntProperty(
        name="Tile X",
        description="Size of seamless X area.",
        default=8,
        min=1,
        update=update_tile_x
    )

    tile_y = IntProperty(
        name="Tile Y",
        description="Size of seamless Y area.",
        default=8,
        min=1,
        update=update_tile_y
    )

    use_tile_x = BoolProperty(
        name="Use X Axis",
        description="Tile proxies on X axis.",
        default=True
    )

    use_tile_y = BoolProperty(
        name="Use Y Axis",
        description="Tile proxies on Y axis.",
        default=True
    )

    use_margin = BoolProperty(
        name="Use Margin",
        description="Enable rigid body margin.",
        default=False,
        update=update_margin
    )

    use_floor = BoolProperty(
        name="Use Floor",
        description="Enable rigid body floor.",
        default=False,
        update=update_floor
    )

    margin = FloatProperty(
        name="Margin",
        description="Rigid body margin around seamless area.",
        default=1.0,
        min=0.0,
        update=update_margin
    )

    floor = FloatProperty(
        name="Floor",
        description="Rigid body floor height for seamless area.",
        default=0,
        update=update_floor
    )

    res_mode = EnumProperty(
        name="Resolution Mode",
        description="Set either minimum or maximum render resolution",
        items=ei_res_mode,
        default='MIN',
        update=update_camera
    )

    min_res = IntProperty(
        name="Minimum Resolution",
        description="Minimum render resolution.",
        subtype="PIXEL",
        default=1024,
        min=1,
        update=update_camera
    )

    max_res = IntProperty(
        name="Maximum Resolution",
        description="Maximum render resolution.",
        subtype="PIXEL",
        default=1024,
        min=1,
        update=update_camera
    )

    show_area = BoolProperty(
        name="Show Area",
        description="Toggle visibility of seamless area.",
        default=True
    )

    show_margin = BoolProperty(
        name="Show Margin",
        description="Toggle visibility of rigid body margin.",
        default=True
    )

    show_floor = BoolProperty(
        name="Show Floor",
        description="Toggle visibility of rigid body floor.",
        default=True
    )

    show_proxies = BoolProperty(
        name="Show Proxies",
        description="Toggle visibility of proxy locations.",
        default=True
    )

    show_compile = BoolProperty(
        name="Compile Seamless Settings",
        description="Toggle visibility of compile seamless settings.",
        default=False
    )

    optimize = BoolProperty(
        name="Optimize Position",
        description="Optimize seamless object position by keeping it inside the seamless area.",
        default=True
    )

    clip = BoolProperty(
        name="Enable Clipping",
        description="Clip seamless proxies for new seamless objects that are not inside the seamless area and margin.",
        default=True
    )

    level = IntProperty(
        name="Proxy Level",
        description="Number of proxy layers to create.",
        default=1,
        min=1
    )

    psys = BoolProperty(
        name="Use Particle Systems",
        description="Turn this off and all particle systems are removed from proxies, otherwise the seamless mode specified in the particle system properties page is used.",
        default=True
    )

    default_hide = BoolProperty(
        name="Hide Proxies",
        description="New proxies are hidden.",
        default=False
    )

    default_hide_select = BoolProperty(
        name="Hide Proxy Select",
        description="New proxies are hidden from selection.",
        default=True
    )

    default_hide_render = BoolProperty(
        name="Hide Proxy Render",
        description="New proxies are hidden from render.",
        default=False
    )

    default_draw_type = EnumProperty(
        name="Proxy Draw Type",
        description="Draw type of new proxies",
        items=ei_draw_type,
        default='BOUNDS'
    )

    vis_hide = BoolProperty(
        name="Hide Proxies",
        description="Hide proxies.",
        default=False
    )

    vis_hide_select = BoolProperty(
        name="Hide Proxy Select",
        description="Hide proxies from selection.",
        default=True
    )

    vis_hide_render = BoolProperty(
        name="Hide Proxy Render",
        description="Hide proxies from render.",
        default=False
    )

    vis_draw_type = EnumProperty(
        name="Proxy Draw Type",
        description="Draw type of proxies",
        items=ei_draw_type,
        default='BOUNDS'
    )

    compile_type = EnumProperty(
        name="Compile Type",
        description="Seamless compile type",
        items=ei_compile_type,
        default='GROUP'
    )

    compile_name = StringProperty(
        name="Compile Name",
        description="Name of group and/or mesh to be compiled.",
        default="name_of_result"
    )

    compile_cleanup = BoolProperty(
        name="Clear Seamless",
        description="Clear seamless area and all dependencies.",
        default=False
    )

    compile_reinsert = BoolProperty(
        name="Reinsert Result",
        description="After compiling reinsert the compiled result into the seamless area.",
        default=True
    )

    compile_clear_rb = BoolProperty(
        name="Clear Rigid Body",
        description="Clear rigid body settings from compiled objects.",
        default=True
    )

    compile_layers = BoolVectorProperty(
        name="Compile Layers",
        description="Layer(s) to place compiled result in... Wow! Still no named layers? What a headache!",
        size=20,
        default=[False] * 20,
        subtype="LAYER"
    )

    compile_mesh_group = BoolProperty(
        name="Use Group",
        description="Use group for resulting mesh and optionally other objects.",
        default=False
    )

    compile_mesh_all = BoolProperty(
        name="All Objects",
        description="Include all non-mesh objects in result.",
        default=False
    )

    compile_mesh_convert = BoolProperty(
        name="Convert Non-Mesh",
        description="Include mesh convertible non-mesh objects (curves, text, surface, etc.).",
        default=True
    )

    compile_mesh_random_vcol_a = BoolProperty(
        name="Random VCOL A",
        description="Add random vertex colors per object.",
        default=False
    )

    compile_mesh_random_vcol_a_name = StringProperty(
        name="Random VCOL A Name",
        description="Name of random vertex color layer.",
        default="vc_rand_a"
    )

    compile_mesh_random_vcol_b = BoolProperty(
        name="Random VCOL B",
        description="Add random vertex colors per object.",
        default=False
    )

    compile_mesh_random_vcol_b_name = StringProperty(
        name="Random VCOL B Name",
        description="Name of random vertex color layer.",
        default="vc_rand_b"
    )

    compile_mesh_random_uv = BoolProperty(
        name="Random UV",
        description="Add random UVs per object.",
        default=False
    )

    compile_mesh_random_uv_name = StringProperty(
        name="Random UV Name",
        description="Name of random UV layer.",
        default="uv_rand"
    )

    compile_mesh_location_uv = BoolProperty(
        name="Location UV",
        description="Add location UVs per object.",
        default=False
    )

    compile_mesh_location_uv_name = StringProperty(
        name="Location UV Name",
        description="Name of location UV layer.",
        default="uv_location"
    )

    compile_mesh_location_uv_name_2 = StringProperty(
        name="Location UV Name 2",
        description="Name of second location UV layer.",
        default="uv_location_2"
    )

    compile_mesh_object_uv = BoolProperty(
        name="Object UV",
        description="Add object space UVs per object.",
        default=False
    )

    compile_mesh_object_uv_name = StringProperty(
        name="Object UV Name",
        description="Name of object space UV layer.",
        default="uv_object"
    )

    compile_mesh_object_uv_name_2 = StringProperty(
        name="Object UV Name 2",
        description="Name of second object space UV layer.",
        default="uv_object_2"
    )

    compile_mesh_object_uv_rot = BoolProperty(
        name="Object UV Apply Rotation",
        description="Apply rotation for object space UVs. Recommended for 2 channel mode.",
        default=False
    )

    compile_mesh_location_uv_ch = EnumProperty(
        name="Location UV Channels",
        description="Channel count for location UVs",
        items=ei_uv_type,
        default="2"
    )

    compile_mesh_location_uv_4m = EnumProperty(
        name="Location UV Fourth",
        description="What to do with the fourth UV channel",
        items=ei_uv_fourth,
        default="RANDOM"
    )

    compile_mesh_object_uv_ch = EnumProperty(
        name="Object UV Channels",
        description="Channel count for object space UVs",
        items=ei_uv_type,
        default="2"
    )

    compile_mesh_object_uv_4m = EnumProperty(
        name="Object UV Fourth",
        description="What to do with the fourth UV channel",
        items=ei_uv_fourth,
        default="RANDOM"
    )


class SeamlessParticleSysProps(PropertyGroup):

    @classmethod
    def register(cls):
        bpy.types.ParticleSettings.seamless = PointerProperty(
            name="Seamless Particle System Properties",
            description="Properties that define handling of particle systems on objects added to the seamless area.",
            type=cls,
        )

    @classmethod
    def unregister(cls):
        try:
            del bpy.types.ParticleSettings.seamless
        except:
            pass

    mode = EnumProperty(
        name="Seamless Particle System Mode",
        description="Action to take for particle system when added to the seamless area. WARNING: This must be set before particle system is added to seamless area",
        items=ei_psys_mode,
        default="LINKED",
    )

    mode_last = EnumProperty(
        items=ei_psys_mode,
        default="LINKED",
    )

    is_proxy = BoolProperty(default=False)

# Addon Properties


class SeamlessAddonPreferences(AddonPreferences):
    bl_idname = __package__

    col_seamless_area = FloatVectorProperty(
        name="Seamless Area",
        description="Color of seamless area.",
        subtype="COLOR",
        size=3,
        default=[1.0, 1.0, 0.0],
        min=0.0,
        max=1.0
    )

    col_seamless_margin = FloatVectorProperty(
        name="Seamless Margin",
        description="Color of seamless area's margin.",
        subtype="COLOR",
        size=3,
        default=[0.0, 0.8, 1.0],
        min=0.0,
        max=1.0
    )

    col_seamless_floor = FloatVectorProperty(
        name="Seamless Floor",
        description="Color of seamless area's floor.",
        subtype="COLOR",
        size=3,
        default=[1.0, 0.2, 0.2],
        min=0.0,
        max=1.0
    )

    col_seamless_proxies = FloatVectorProperty(
        name="Seamless Proxies",
        description="Color of seamless proxy locations.",
        subtype="COLOR",
        size=3,
        default=[1.0, 0.0, 1.0],
        min=0.0,
        max=1.0
    )

    show_help_panel = BoolProperty(
        name="Show Help Panel",
        description="Toggle display of help panel containing a link to the documentation.",
        default=True
    )

    def draw(self, context):
        l = self.layout
        r = l.split(percentage=0.5)
        c = r.column()
        b = c.box()
        cc = b.column(True)
        cc.row(True).prop(self, "col_seamless_area")
        cc.row(True).prop(self, "col_seamless_margin")
        cc.row(True).prop(self, "col_seamless_floor")
        cc.row(True).prop(self, "col_seamless_proxies")
        c = r.column()
        c.scale_y = 1.5
        c.operator(SeamlessOperator_ViewDocs.bl_idname, "View Documentation", icon="QUESTION")
        b = c.box()
        cc = b.column(True)
        cc.row(True).prop(self, "show_help_panel")

# Panels


def layout_opop(o, n, l, p, text="", icon="NONE"):
    row = l.row(align=True)
    box = row.box()
    split = box.row(align=True)
    show = getattr(p, n, False)
    if show:
        split.prop(p, n, text="", icon="DISCLOSURE_TRI_DOWN_VEC")
    else:
        split.prop(p, n, text="", icon="DISCLOSURE_TRI_RIGHT_VEC")
    split.operator(o.bl_idname, text=text, icon=icon)
    return show, box


class SeamlessAreaPanel(Panel):
    bl_label = "Area"
    bl_space_type = "VIEW_3D"
    bl_region_type = "TOOLS"
    bl_context = "objectmode"
    bl_category = "Seamless"

    def draw(self, context):
        l = self.layout
        p = context.scene.seamless
        r = l.row(True)
        r.prop(p, "tile_x", "X")
        r.prop(p, "tile_y", "Y")
        rr = r.row(True)
        rr.alignment = "LEFT"
        rr.prop(p, "use_tile_x", "X", toggle=True)
        rr.prop(p, "use_tile_y", "Y", toggle=True)
        c = l.column(True)
        r = c.row(True)
        r.row(True).prop(p, "use_margin", "Margin", toggle=True, icon="FILE_TICK" if p.use_margin else "BLANK1")
        r = r.row(True)
        r.enabled = p.use_margin
        r.prop(p, "margin", "")
        r = c.row(True)
        r.row(True).prop(p, "use_floor", "Floor", toggle=True, icon="FILE_TICK" if p.use_floor else "BLANK1")
        r = r.row(True)
        r.enabled = p.use_floor
        r.prop(p, "floor", "")


class SeamlessToolsPanel(Panel):
    bl_label = "Tools"
    bl_space_type = "VIEW_3D"
    bl_region_type = "TOOLS"
    bl_context = "objectmode"
    bl_category = "Seamless"

    def draw(self, context):
        l = self.layout
        p = context.scene.seamless
        c = l.column(True)
        r = c.row(True)
        r.operator(SeamlessOperator_Add.bl_idname, "Add", icon="ZOOMIN")
        r.operator(SeamlessOperator_Remove.bl_idname, "Remove", icon="ZOOMOUT")
        r = c.row(True)
        r.prop(p, "level", "Layers")
        r.prop(p, "psys", "", toggle=True, icon="PARTICLES")
        r.prop(p, "clip", "", toggle=True, icon="STICKY_UVS_LOC" if p.clip else "STICKY_UVS_DISABLE")
        r.prop(p, "optimize", "", toggle=True, icon="AXIS_TOP")
        r = c.row(True)
        if p.default_hide:
            r.prop(p, "default_hide", "", icon="RESTRICT_VIEW_ON")
        else:
            r.prop(p, "default_hide", "", icon="RESTRICT_VIEW_OFF")
        if p.default_hide_select:
            r.prop(p, "default_hide_select", "", icon="RESTRICT_SELECT_ON")
        else:
            r.prop(p, "default_hide_select", "", icon="RESTRICT_SELECT_OFF")
        if p.default_hide_render:
            r.prop(p, "default_hide_render", "", icon="RESTRICT_RENDER_ON")
        else:
            r.prop(p, "default_hide_render", "", icon="RESTRICT_RENDER_OFF")
        r.prop(p, "default_draw_type", "")
        r = c.row(True)
        r.alignment = "EXPAND"
        r.operator(SeamlessOperator_Refresh.bl_idname, "Refresh", icon="FILE_REFRESH").selected = False
        r.operator(SeamlessOperator_Refresh.bl_idname, "", icon="RESTRICT_SELECT_OFF").selected = True
        c = l.column(True)
        r = c.row(True)
        r.operator(SeamlessOperator_Select.bl_idname, "Select", icon="RESTRICT_SELECT_OFF")
        r.operator(SeamlessOperator_Deselect.bl_idname, "Deselect", icon="RESTRICT_SELECT_ON")
        r = c.row(True)
        r.operator(SeamlessOperator_InvertSelection.bl_idname, "Invert Selection", icon="AUTOMERGE_ON")
        r = c.row(True)
        r.operator(SeamlessOperator_SelectSeamlessArea.bl_idname, "Select Area", icon="BORDER_RECT")
        r = c.row(True)
        r.operator(SeamlessOperator_CursorToSeamlessArea.bl_idname, "Cursor to Area", icon="CURSOR")
        c = l.column(True)
        r = c.row(True)
        r.operator(SeamlessOperator_ApplyVisualTransform.bl_idname, "Apply Visual Tx", icon="EXPORT").selected = False
        r.operator(SeamlessOperator_ApplyVisualTransform.bl_idname, "", icon="RESTRICT_SELECT_OFF").selected = True
        r = c.row(True)
        r.operator(SeamlessOperator_ActiveToPassive.bl_idname, "Active To Passive", icon="PHYSICS").selected = False
        r.operator(SeamlessOperator_ActiveToPassive.bl_idname, "", icon="RESTRICT_SELECT_OFF").selected = True
        r = c.row(True)
        ops = r.operator(SeamlessOperator_Clip.bl_idname, "Enable Clipping", icon="STICKY_UVS_LOC")
        ops.selected = False
        ops.clip = True
        ops = r.operator(SeamlessOperator_Clip.bl_idname, "", icon="RESTRICT_SELECT_OFF")
        ops.selected = True
        ops.clip = True
        r = c.row(True)
        ops = r.operator(SeamlessOperator_Clip.bl_idname, "Disable Clipping", icon="STICKY_UVS_DISABLE")
        ops.selected = False
        ops.clip = False
        ops = r.operator(SeamlessOperator_Clip.bl_idname, "", icon="RESTRICT_SELECT_OFF")
        ops.selected = True
        ops.clip = False
        c = l.column(True)
        r = c.row(True)
        if p.vis_hide:
            r.prop(p, "vis_hide", "", icon="RESTRICT_VIEW_ON")
        else:
            r.prop(p, "vis_hide", "", icon="RESTRICT_VIEW_OFF")
        if p.vis_hide_select:
            r.prop(p, "vis_hide_select", "", icon="RESTRICT_SELECT_ON")
        else:
            r.prop(p, "vis_hide_select", "", icon="RESTRICT_SELECT_OFF")
        if p.vis_hide_render:
            r.prop(p, "vis_hide_render", "", icon="RESTRICT_RENDER_ON")
        else:
            r.prop(p, "vis_hide_render", "", icon="RESTRICT_RENDER_OFF")
        r.prop(p, "vis_draw_type", "")
        r = c.row(True)
        r.operator(SeamlessOperator_SetProxyVisibility.bl_idname, "All", icon="GROUP").selected = False
        r.operator(SeamlessOperator_SetProxyVisibility.bl_idname, "Selected", icon="RESTRICT_SELECT_OFF").selected = True
        show, b = layout_opop(SeamlessOperator_Compile, "show_compile", l, p, "Compile Mesh" if p.compile_type == "MESH" else "Compile Group", "RADIO")
        if show:
            c = b.column(True)
            c.prop(p, "compile_type", "")
            c.prop(p, "compile_name", "")
            c.separator()
            c.prop(p, "compile_layers", "")
            c.separator()
            c.prop(p, "compile_cleanup")
            c.prop(p, "compile_clear_rb")
            r = c.row(True)
            r.enabled = not p.compile_cleanup
            r.prop(p, "compile_reinsert")
            if p.compile_type == "MESH":
                bb = b.box()
                cc = bb.column(True)
                cc.prop(p, "compile_mesh_group")
                r = cc.row(True)
                r.enabled = p.compile_mesh_group
                r.label("", icon="BLANK1")
                r.prop(p, "compile_mesh_all")
                cc.prop(p, "compile_mesh_convert")
                cc.label("Vertex Colors:")
                r = cc.row(True)
                r.label("", icon="BLANK1")
                r.prop(p, "compile_mesh_random_vcol_a", "Random A")
                if p.compile_mesh_random_vcol_a:
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_random_vcol_a_name", "")
                r = cc.row(True)
                r.label("", icon="BLANK1")
                r.prop(p, "compile_mesh_random_vcol_b", "Random B")
                if p.compile_mesh_random_vcol_b:
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_random_vcol_b_name", "")
                cc.label("UVs:")
                r = cc.row(True)
                r.label("", icon="BLANK1")
                r.prop(p, "compile_mesh_random_uv", "Random")
                if p.compile_mesh_random_uv:
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_random_uv_name", "")
                r = cc.row(True)
                r.label("", icon="BLANK1")
                r.prop(p, "compile_mesh_location_uv", "Location")
                if p.compile_mesh_location_uv:
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_location_uv_ch", "")
                    if p.compile_mesh_location_uv_ch == "4":
                        r = cc.row(True)
                        r.label("", icon="BLANK1")
                        r.label("", icon="BLANK1")
                        r.prop(p, "compile_mesh_location_uv_4m", "")
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_location_uv_name", "")
                    if p.compile_mesh_location_uv_ch == "4":
                        r = cc.row(True)
                        r.label("", icon="BLANK1")
                        r.label("", icon="BLANK1")
                        r.prop(p, "compile_mesh_location_uv_name_2", "")
                r = cc.row(True)
                r.label("", icon="BLANK1")
                r.prop(p, "compile_mesh_object_uv", "Object Space")
                if p.compile_mesh_object_uv:
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_object_uv_rot", "Rotate", toggle=True)
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_object_uv_ch", "")
                    if p.compile_mesh_object_uv_ch == "4":
                        r = cc.row(True)
                        r.label("", icon="BLANK1")
                        r.label("", icon="BLANK1")
                        r.prop(p, "compile_mesh_object_uv_4m", "")
                    r = cc.row(True)
                    r.label("", icon="BLANK1")
                    r.label("", icon="BLANK1")
                    r.prop(p, "compile_mesh_object_uv_name", "")
                    if p.compile_mesh_object_uv_ch == "4":
                        r = cc.row(True)
                        r.label("", icon="BLANK1")
                        r.label("", icon="BLANK1")
                        r.prop(p, "compile_mesh_object_uv_name_2", "")

        r = l.row()
        r = r.box().row(True)
        r.operator(SeamlessOperator_RemoveAll.bl_idname, "Remove All", icon="X")
        r.operator(SeamlessOperator_Cleanup.bl_idname, "", icon="ERROR")


class SeamlessDisplayPanel(Panel):
    bl_label = "Display"
    bl_space_type = "VIEW_3D"
    bl_region_type = "TOOLS"
    bl_context = "objectmode"
    bl_category = "Seamless"
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        l = self.layout
        p = context.scene.seamless
        c = l.column(True)
        r = c.row(True)
        r.prop(p, "show_area", "Area")
        r.prop(p, "show_proxies", "Proxies")
        r = c.row(True)
        r.enabled = p.show_area
        r.prop(p, "show_margin", "Margin")
        r.prop(p, "show_floor", "Floor")


class SeamlessCameraPanel(Panel):
    bl_label = "Camera"
    bl_space_type = "VIEW_3D"
    bl_region_type = "TOOLS"
    bl_context = "objectmode"
    bl_category = "Seamless"

    def draw(self, context):
        l = self.layout
        p = context.scene.seamless
        nocam = SeamlessOperator_CreateCamera.poll(context)
        c = l.column(True)
        if nocam:
            c.operator(SeamlessOperator_CreateCamera.bl_idname, "Create Camera", icon="OUTLINER_OB_CAMERA")
        else:
            c.operator(SeamlessOperator_DeleteCamera.bl_idname, "Delete Camera", icon="X")
        r = c.row(True)
        r.operator(SeamlessOperator_FlipCamera.bl_idname, "Flip", icon="LAYER_USED")
        r.operator(SeamlessOperator_ResetCamera.bl_idname, "Reset", icon="LAYER_USED")
        c = l.column(True)
        if nocam:
            c.enabled = False
        c.label("Resolution:")
        s = c.row().split(0.4, True)
        s.prop(p, "res_mode", "")
        if p.res_mode == "MIN":
            s.prop(p, "min_res", "")
        else:
            s.prop(p, "max_res", "")


class SeamlessInfoPanel(Panel):
    bl_label = "Help"
    bl_space_type = "VIEW_3D"
    bl_region_type = "TOOLS"
    bl_context = "objectmode"
    bl_category = "Seamless"
    bl_options = {'DEFAULT_CLOSED'}

    @classmethod
    def poll(cls, context):
        return uperf.show_help_panel

    def draw(self, context):
        l = self.layout
        l.scale_y = 1.5
        l.operator(SeamlessOperator_ViewDocs.bl_idname, "View Documentation", icon="QUESTION")


class SeamlessNodeEditorPanel(Panel):
    bl_space_type = 'NODE_EDITOR'
    bl_region_type = 'UI'
    bl_label = "Seamless Tools"

    @classmethod
    def poll(cls, context):
        space = context.space_data
        return space.type == "NODE_EDITOR" and space.tree_type == "ShaderNodeTree"

    def draw(self, context):
        l = self.layout
        c = l.column(True)
        c.operator(SeamlessOperator_LoadNodeGroups.bl_idname, "Load Node Groups", icon="NODETREE")
        c.operator(SeamlessOperator_RefreshNodeGroups.bl_idname, "Refresh Node Groups", icon="FILE_REFRESH")
        g = bpy.data.node_groups
        try:
            s = g["Seamless Area"].nodes["resolution"].outputs[0]
        except:
            pass
        else:
            c = l.box().column(True)
            c.label("Approx Object Location:")
            c.prop(s, "default_value", "Resolution")


def particle_refresh(self, context):
    ob = context.object
    is_seamless = False
    try:
        is_seamless = ob.parent.name == SEAMLESS_OBJECTS_NAME
    except:
        pass

    psys = context.particle_system
    settings = psys.settings
    if not settings:
        return

    p = settings.seamless
    l = self.layout
    c = l.column(True)
    c.label("Seamless Settings:")
    b = c.box()
    c = b.column(True)
    if is_seamless and p.mode != p.mode_last:
        r = c.row(True)
        r.label("Reinsertion required!", icon="ERROR")
    r = c.row(True)
    r.prop(p, "mode", "")
    r.operator(SeamlessOperator_RefreshProxyParticleSystem.bl_idname, "Refresh", icon="FILE_REFRESH")

arrow_verts = [
    Vector((0.0, 0.0, 4.0)),
    Vector((0.0, 0.0, 0.0)),

    Vector((0.0, 0.0, 4.0)),
    Vector((0.0, 0.2, 3.8)),

    Vector((0.0, 0.0, 4.0)),
    Vector((0.0, -0.2, 3.8)),

    Vector((0.0, 0.0, 4.0)),
    Vector((0.2, 0.0, 3.8)),

    Vector((0.0, 0.0, 4.0)),
    Vector((-0.2, 0.0, 3.8))
]

area_quads = [
    (Vector((1, 1, 3.8)), 0),
    (Vector((-1, 1, 3.8)), 0),
    (Vector((-1, 1, 0)), 1),
    (Vector((1, 1, 0)), 1),

    (Vector((1, -1, 3.8)), 0),
    (Vector((-1, -1, 3.8)), 0),
    (Vector((-1, -1, 0)), 1),
    (Vector((1, -1, 0)), 1),

    (Vector((1, 1, 3.8)), 0),
    (Vector((1, 1, 0)), 1),
    (Vector((1, -1, 0)), 1),
    (Vector((1, -1, 3.8)), 0),

    (Vector((-1, 1, 3.8)), 0),
    (Vector((-1, 1, 0)), 1),
    (Vector((-1, -1, 0)), 1),
    (Vector((-1, -1, 3.8)), 0),
]

default_mat = Matrix()
cb_handle = None


def draw_callback_seamless(context):
    props = context.scene.seamless

    sa = get_seamless_area(context)
    selected = False
    if sa:
        if not context.scene in sa.users_scene:
            return
        vis = False
        sal = sa.layers
        vl = context.scene.layers
        for i, l in enumerate(vl):
            if l and l == sal[i]:
                vis = True
                break
        if not vis:
            return
        mat = sa.matrix_world
        selected = sa.select
    else:
        return

    glDepthMask(GL_FALSE)
    if props.show_proxies:
        proxy_group = get_sp_group()
        if proxy_group:
            col_pr = uperf.col_seamless_proxies
            proxy_objects = proxy_group.objects
            glEnable(GL_BLEND)
            glPointSize(2.0)
            glColor4f(col_pr[0], col_pr[1], col_pr[2], 1.0 if selected else 0.7)
            glBegin(GL_POINTS)
            for proxy in proxy_objects:
                glVertex3f(*proxy.matrix_world.translation)
            glEnd()

    level = 0.2 if selected else 0.1
    if props.show_area:
        col_area = uperf.col_seamless_area

        x = float(props.tile_x)
        y = float(props.tile_y)
        hx = x / 2.0
        hy = y / 2.0

        ox = Vector((hx, hy, 0.0))
        lines = [mat * (vert + ox) for vert in arrow_verts]

        ox[0] = -ox[0]
        lines.extend([mat * (vert + ox) for vert in arrow_verts])

        ox[1] = -ox[1]
        lines.extend([mat * (vert + ox) for vert in arrow_verts])

        ox[0] = -ox[0]
        lines.extend([mat * (vert + ox) for vert in arrow_verts])

        h_bounds = [
            Vector((hx, hy, 0.0)),
            Vector((-hx, hy, 0.0)),
            Vector((hx, -hy, 0.0)),
            Vector((-hx, -hy, 0.0)),
            Vector((hx, hy, 0.0)),
            Vector((hx, -hy, 0.0)),
            Vector((-hx, hy, 0.0)),
            Vector((-hx, -hy, 0.0)),
        ]

        lines.extend([mat * vert for vert in h_bounds])

        quads = []
        for vert, value in area_quads:
            vert = vert.copy()
            vert[0] *= hx
            vert[1] *= hy
            quads.append((mat * vert, value))

        glEnable(GL_BLEND)
        glColor4f(col_area[0], col_area[1], col_area[2], 1.0 if selected else 0.5)

        glBegin(GL_LINES)
        for vert in lines:
            glVertex3f(*vert)
        glEnd()

        glBlendFunc(GL_ONE, GL_ONE)
        glShadeModel(GL_SMOOTH)
        area_color = (col_area[0] * level, col_area[1] * level, col_area[2] * level)
        glBegin(GL_QUADS)
        for vert, value in quads:
            if value:
                glColor3f(*area_color)
            else:
                glColor4f(0.0, 0.0, 0.0, 1)
            glVertex3f(*vert)
        glEnd()

        if props.use_margin and props.show_margin and props.margin > 0.001:
            col_margin = uperf.col_seamless_margin
            margin = props.margin
            lines = []
            ox = Vector((hx + margin, hy + margin, 0.0))
            lines = [mat * (vert + ox) for vert in arrow_verts]

            ox[0] = -ox[0]
            lines.extend([mat * (vert + ox) for vert in arrow_verts])

            ox[1] = -ox[1]
            lines.extend([mat * (vert + ox) for vert in arrow_verts])

            ox[0] = -ox[0]
            lines.extend([mat * (vert + ox) for vert in arrow_verts])

            div = 3
            inc = margin / div
            for i in range(div):
                for v in h_bounds:
                    if v[0] < 0.0:
                        v[0] -= inc
                    else:
                        v[0] += inc
                    if v[1] < 0.0:
                        v[1] -= inc
                    else:
                        v[1] += inc

                lines.extend([mat * vert for vert in h_bounds])
            lines.extend([mat * (vert + Vector((0.0, 0.0, 1.0))) for vert in h_bounds])
            lines.extend([mat * (vert + Vector((0.0, 0.0, 2.0))) for vert in h_bounds])

            quads = []
            for vert, value in area_quads:
                vert = vert.copy()
                vert[0] *= hx + margin
                vert[1] *= hy + margin
                vert[2] *= 0.5
                quads.append((mat * vert, value))

            glColor4f(col_margin[0], col_margin[1], col_margin[2], 1.0 if selected else 0.5)

            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            glBegin(GL_LINES)
            for vert in lines:
                glVertex3f(*vert)
            glEnd()

            glBlendFunc(GL_ONE, GL_ONE)
            glShadeModel(GL_SMOOTH)
            area_color = (col_margin[0] * level, col_margin[1] * level, col_margin[2] * level)
            glBegin(GL_QUADS)
            for vert, value in quads:
                if value:
                    glColor3f(*area_color)
                else:
                    glColor4f(0.0, 0.0, 0.0, 1)
                glVertex3f(*vert)
            glEnd()

        if props.use_floor and props.show_floor:
            col_floor = uperf.col_seamless_floor
            lines = []
            floor = props.floor
            margin = props.margin if props.use_margin else 0
            div = 4
            hhx = hx + margin
            hhy = hy + margin
            inc_x = (hhx * 2) / div
            inc_y = (hhy * 2) / div
            for i in range(div + 1):
                value = (inc_x * i) - hhx
                lines.extend([
                    mat * Vector((value, hhy, floor)),
                    mat * Vector((value, -hhy, floor)),
                ])
            for i in range(div + 1):
                value = (inc_y * i) - hhy
                lines.extend([
                    mat * Vector((hhx, value, floor)),
                    mat * Vector((-hhx, value, floor)),
                ])

            quads = [
                mat * Vector((hhx, hhy, floor)),
                mat * Vector((-hhx, hhy, floor)),
                mat * Vector((-hhx, -hhy, floor)),
                mat * Vector((hhx, -hhy, floor)),
            ]

            glColor4f(col_floor[0], col_floor[1], col_floor[2], 1.0 if selected else 0.5)

            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            glBegin(GL_LINES)
            for vert in lines:
                glVertex3f(*vert)
            glEnd()

            glBlendFunc(GL_ONE, GL_ONE)
            area_color = (col_floor[0] * level, col_floor[1] * level, col_floor[2] * level)
            glColor3f(*area_color)
            glBegin(GL_QUADS)
            for vert in quads:
                glVertex3f(*vert)
            glEnd()

    glDepthMask(GL_TRUE)

# Init Stuff


def install_draw_callback(scene):
    bpy.app.handlers.scene_update_post.remove(install_draw_callback)
    global cb_handle
    cb_handle = bpy.types.SpaceView3D.draw_handler_add(draw_callback_seamless, (bpy.context,), 'WINDOW', 'POST_VIEW')


def register():
    bpy.app.handlers.scene_update_post.append(install_draw_callback)
    bpy.utils.register_module(__name__)
    global uperf
    uperf = bpy.context.user_preferences.addons[__name__].preferences
    bpy.types.PARTICLE_PT_context_particles.append(particle_refresh)


def unregister():
    bpy.types.PARTICLE_PT_context_particles.remove(particle_refresh)
    if cb_handle != None:
        bpy.types.SpaceView3D.draw_handler_remove(cb_handle, 'WINDOW')
    bpy.utils.unregister_module(__name__)

if __name__ == "__main__":
    register()
